<!--- test -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NASHMIDI v1.2</title>
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <script src="https://unpkg.com/tone"></script>
    <style>
        :root {
            --bg-color: #f4f7fa;
            --app-bg: #ffffff;
            --piano-bg: #eef1f5;
            --shadow-color: rgba(100, 100, 150, 0.15);
            --border-color: #d8dee7;
            --text-color: #3d4a5c;
            --text-light-color: #8a96a8;
            --accent-color: #5e81f4;
            --accent-hover-color: #4a6cdc;
            --hit-line-color: #ff7b7b;
            --piano-outline-color: #d1d5db;
            --pulse-duration: 1.2s;
            /* -- Custom properties for loading VFX -- */
            --loading-ribbon-thickness: 8px;
            --loading-blur-amount: 5px;
            /* -- NEW: Note Label Colors -- */
            --note-label-fill-color: #ffffff;
            --note-label-outline-color: #000000;
            /* -- NEW: Grid Shading Opacity -- */
            --grid-black-key-opacity: 0.05;
            /* -- MODIFIED: Guidance Mode Colors & Opacity -- */
            --guidance-color: #5e81f4;
            --guidance-opacity: 1.0;
            /* -- NEW: Note Outline Properties -- */
            --note-outline-width: 1px;
            --note-outline-color: #000000;
            
            /* -- Dark Theme Variables -- */
            --dark-bg-color: #1a1b26;
            --dark-app-bg: #24283b;
            --dark-piano-bg: #1e2029;
            --dark-aside-bg: #20222e;
            --dark-shadow-color: rgba(0, 0, 0, 0.25);
            --dark-border-color: #3b4261;
            --dark-text-color: #c0caf5;
            --dark-text-light-color: #737aa2;
            --dark-accent-color: #7aa2f7;
            --dark-accent-hover-color: #6289e2;
            --dark-hit-line-color: #f7768e;
            --dark-piano-outline-color: #3b4261;
            --dark-note-label-fill-color: #000000;
            --dark-note-label-outline-color: #ffffff;
            --dark-guidance-color: #7aa2f7;
            --dark-note-outline-color: #ffffff;
            /* -- NEW: Dim Overlay Opacity -- */
            --dim-overlay-opacity: 0.25;
        }

        /* NEW: Dark Mode Styles -- */
        body.dark-mode {
            --bg-color: var(--dark-bg-color);
            --app-bg: var(--dark-app-bg);
            --piano-bg: var(--dark-piano-bg);
            --shadow-color: var(--dark-shadow-color);
            --border-color: var(--dark-border-color);
            --text-color: var(--dark-text-color);
            --text-light-color: var(--dark-text-light-color);
            --accent-color: var(--dark-accent-color);
            --accent-hover-color: var(--dark-accent-hover-color);
            --hit-line-color: var(--dark-hit-line-color);
            --piano-outline-color: var(--dark-piano-outline-color);
            /* -- NEW: Note Label Dark Mode Colors -- */
            --note-label-fill-color: var(--dark-note-label-fill-color);
            --note-label-outline-color: var(--dark-note-label-outline-color);
            /* -- MODIFIED: Guidance Mode Dark Color -- */
            --guidance-color: var(--dark-guidance-color);
            /* -- NEW: Note Outline Dark Color -- */
            --note-outline-color: var(--dark-note-outline-color);
        }
        body.dark-mode aside { background-color: var(--dark-aside-bg); }
        body.dark-mode .white-key { background-color: #a9b1d6; }
        body.dark-mode .black-key { background-color: #24283b; border: 1px solid var(--dark-piano-outline-color); }
        body.dark-mode .icon-btn:hover { background-color: #3b4261; }
        body.dark-mode input[type="range"] { background: #3b4261; }
        body.dark-mode input[type="checkbox"].toggle { background-color: #3b4261; }
        body.dark-mode .panel { background-color: var(--dark-app-bg); }
        body.dark-mode .drop-zone.dragover .panel-content-inner { background-color: #2f344d; border-color: var(--dark-accent-color); }
        body.dark-mode #channel-mixer-list li:hover, body.dark-mode .keybind-item:hover { background-color: var(--dark-piano-bg); }
        body.dark-mode .keybind-btn { background-color: var(--dark-piano-bg); }
        body.dark-mode .keybind-btn:hover { background-color: #3b4261; }
        body.dark-mode .panel-content-inner select { background-color: var(--dark-aside-bg); }
        body.dark-mode #drum-map-display li:nth-child(odd) { background-color: var(--dark-aside-bg); }
        body.dark-mode #sync-visualizer { background-color: var(--dark-piano-bg); }
        body.dark-mode #sync-tap-list span { background-color: var(--dark-piano-bg); }
        body.dark-mode #theme-editor .settings-list select { background-color: var(--dark-aside-bg); }
        body.dark-mode .midipack-item { border-color: var(--dark-border-color); }
        body.dark-mode .midipack-header { background-color: var(--dark-aside-bg); }
        body.dark-mode .midipack-song-item:hover { background-color: var(--dark-piano-bg); }

        /* --- Keyframes --- */
@keyframes pulse-effect {
            0% { opacity: 0.9; filter: brightness(1.2); }
            60% { opacity: 0.9; filter: brightness(1); }
            99% { opacity: 0.6; filter: brightness(1); }
            100% { opacity: 0.0; filter: brightness(1); }
        }
        
        @keyframes note-pulse-wipe {
            from { height: 0%; opacity: 0.8; }
            to { height: 100%; opacity: 0; }
        }
        @keyframes column-flash {
            from { opacity: 0.35; }
            to { opacity: 0; }
        }
        @keyframes column-wave {
            from { transform: translateY(0); opacity: 0.6; }
            to { transform: translateY(-100vh); opacity: 0; }
        }
        @keyframes wave-anim {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        @keyframes move-blur-1 {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.3; }
            50% { transform: translate(80px, 40px) scale(1.2); opacity: 0.5; }
        }
        @keyframes move-blur-2 {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.4; }
            50% { transform: translate(-60px, -30px) scale(0.8); opacity: 0.2; }
        }
        @keyframes draw-ribbon { to { stroke-dashoffset: 0; } }
        @keyframes judgement-anim {
            0% { transform: translateX(-50%) translateY(0) scale(0.8); opacity: 1; }
            20% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
            100% { transform: translateX(-50%) translateY(-30px) scale(1); opacity: 0; }
        }
        @keyframes note-hit-anim {
            from { transform: scale(1.2); opacity: 1; }
            to { transform: scale(1.5); opacity: 0; }
        }
        @keyframes scrollDot {
            0% { left: -5%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { left: 105%; opacity: 0; }
        }
        @keyframes rewindDot {
            from { left: 105%; opacity: 0; }
            to { left: -5%; opacity: 0; }
        }
        @keyframes stamp-pulse {
            0% { transform: translate(-50%, -50%) scale(1.6); opacity: 0.9; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }

        @keyframes sync-bar-fill {
            from { width: 0%; }
            to { width: 100%; }
        }
        @keyframes sync-marker-hit {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.25); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        @keyframes countdown-pop {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.1); opacity: 0; }
        }

        @keyframes key-guidance-glow {
            0%, 100% { box-shadow: 0 0 6px 2px var(--guidance-color), inset 0 0 5px 1px var(--guidance-color); }
            50% { box-shadow: 0 0 12px 4px var(--guidance-color), inset 0 0 10px 2px var(--guidance-color); }
        }
        /* MODIFIED: Fixed outline clipping by using only inset shadow */
        @keyframes key-guidance-outline {
            0%, 100% { box-shadow: inset 0 0 0 2px var(--guidance-color); }
            50% { box-shadow: inset 0 0 0 3px var(--guidance-color); }
        }
        /* MODIFIED: Animation now uses a dynamic variable for the glow color */
        @keyframes kb-key-press {
            0% { transform: translateY(0); box-shadow: inset 0 -4px 0 rgba(0,0,0,0.2), 0 0 15px var(--kb-key-glow-color, var(--accent-color)); }
            100% { transform: translateY(2px); box-shadow: inset 0 -2px 0 rgba(0,0,0,0.2), 0 0 5px var(--kb-key-glow-color, var(--accent-color)); }
        }


	/* --- Base Layout --- */
	html, body {
 	   height: 100%; margin: 0; padding: 0;
 	   font-family: 'Poppins', sans-serif;
 	   /* background-color: var(--bg-color); <-- REMOVE THIS LINE */
 	   color: var(--text-color);
 	   display: flex; justify-content: center; align-items: center;
 	   overflow: hidden;
	   transition: background-color 0.3s, color 0.3s;
	}

	/* ADD THE BACKGROUND COLOR PROPERTY HERE INSTEAD */
	body {
	    background-color: var(--bg-color);
	}

        #app-container {
            width: 95vw; max-width: 1400px; height: 90vh;
            background-color: var(--app-bg);
            border-radius: 24px;
            box-shadow: 0 15px 40px var(--shadow-color);
            display: flex;
            overflow: hidden;
            transition: background-color 0.3s, width 0.4s ease-in-out, box-shadow 0.3s;
            position: relative;
        }

        main { flex-grow: 1; display: flex; flex-direction: column; padding: 20px; transition: width 0.4s ease-in-out;}
        /* MODIFIED: Removed overflow-y to allow for internal scrolling container */
        aside {
            width: 320px; flex-shrink: 0;
            background-color: #f8fafd;
            border-left: 1px solid var(--border-color);
            padding: 20px; display: flex; flex-direction: column;
            transition: opacity 0.4s, width 0.4s ease-in-out, background-color 0.3s, border-color 0.3s;
        }
        
        /* NEW: Added a scrollable container for aside content */
        #aside-scroll-wrapper {
            flex-grow: 1;
            overflow-y: auto;
            min-height: 0;
            padding-right: 5px; /* space for scrollbar */
            margin-right: -5px;
        }
        #aside-scroll-wrapper::-webkit-scrollbar { width: 8px; }
        #aside-scroll-wrapper::-webkit-scrollbar-track { background: transparent; }
        #aside-scroll-wrapper::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 4px; }
        #aside-scroll-wrapper::-webkit-scrollbar-thumb:hover { background-color: var(--text-light-color); }
        
        #app-container.game-mode-active aside {
            width: 0; opacity: 0; padding: 0;
            border-left: none; overflow: hidden;
        }
        #app-container.game-mode-active main { width: 100%; }
        #app-container.game-mode-active #controls { grid-template-columns: 1fr auto auto auto 1fr; }
        
        #tabs-nav {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
            flex-shrink: 0;
            position: relative;
        }
        .tab-btn {
            padding: 10px 15px; border: none; background: none; cursor: pointer;
            font-family: 'Poppins', sans-serif; font-size: 0.9em; color: var(--text-light-color);
            position: relative;
            display: flex; align-items: center; justify-content: center;
            flex-grow: 1;
            transition: color 0.2s;
        }
        .tab-btn svg { width: 22px; height: 22px; fill: var(--text-light-color); transition: fill 0.2s; }
        .tab-btn:hover svg, .tab-btn:hover { color: var(--text-color); }
        .tab-btn.active svg { fill: var(--accent-color); }
        
        #tab-underline {
            position: absolute;
            bottom: -1px;
            height: 2px;
            background-color: var(--accent-color);
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .tab-content { display: none; flex-direction: column; gap: 20px; }
        .tab-content.active { display: flex; }

        #visual-engine { flex-grow: 1; display: flex; flex-direction: column; position: relative; border-radius: 16px; overflow: hidden; background-color: var(--piano-bg); border: 1px solid var(--border-color); transition: background-color 0.3s, border-color 0.3s; }
        #visualizer-wrapper { flex-grow: 1; position: relative; overflow: hidden; border-bottom: 3px solid var(--hit-line-color); transition: border-color 0.3s ease, border-bottom-width 0.3s ease-out; }
        body.hit-line-hidden #visualizer-wrapper { border-bottom-width: 0; }
        #piano-container { display: flex; position: relative; width: 100%; height: 100px; background: transparent; flex-shrink: 0; border-top: 1px solid var(--piano-outline-color); transition: border-top-color 0.3s ease; }
        body.piano-outline-hidden #piano-container { border-top-color: transparent; }
        
        #dim-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--accent-color); opacity: 0; transition: opacity 0.5s ease-in-out; z-index: 3; pointer-events: none; }
        #dim-overlay.visible { opacity: var(--dim-overlay-opacity, 0.25); }

        #loading-fx-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 4; display: flex; justify-content: center; align-items: center; pointer-events: none; opacity: 0; transition: opacity 0.5s ease-in-out; }
        #loading-fx-container.visible { opacity: 1; }
        .blur-shape { position: absolute; border-radius: 50%; filter: blur(80px); }
        .blur-shape-1 { width: 300px; height: 300px; background: radial-gradient(circle, hsla(227, 88%, 78%, 0.7) 0%, hsla(227, 88%, 78%, 0) 70%); animation: move-blur-1 12s ease-in-out infinite; }
        .blur-shape-2 { width: 250px; height: 250px; bottom: 10%; right: 15%; background: radial-gradient(circle, hsla(300, 88%, 78%, 0.6) 0%, hsla(300, 88%, 78%, 0) 70%); animation: move-blur-2 15s ease-in-out infinite; }
        
        #loading-text { display: flex; position: relative; }
        .char-container span { position: relative; z-index: 2; display: inline-block; font-size: 1.5em; font-weight: 600; color: #fff; text-shadow: 0 1px 3px rgba(0,0,0,0.2); padding: 0 2px; animation: wave-anim 1.6s ease-in-out infinite; animation-delay: calc(var(--i) * 0.06s); }

        #loading-ribbon-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; display: none; overflow: visible; }
        #loading-ribbon-path { stroke: var(--accent-color); stroke-width: var(--loading-ribbon-thickness); stroke-linecap: round; stroke-linejoin: round; fill: none; }
        
        .loading-blur { filter: blur(var(--loading-blur-amount)); transition: filter 0.5s ease-in-out; }
        #pulse-container, #notes-container { transition: filter 0.5s ease-in-out; }
        #piano-container { transition: filter 0.5s ease-in-out, background-color 0.3s, border-top-color 0.3s ease; }

        #pulse-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; overflow: hidden; }
        .pulse-column { position: absolute; bottom: 0; height: 100%; }
        .pulse-column::before, .pulse-column::after { content: ''; position: absolute; left: 0; width: 100%; }
        .pulse-column::before { top: 0; height: 100%; background: linear-gradient( to bottom, transparent 0%, var(--pulse-color) 20%, var(--pulse-color) 80%, transparent 100% ); animation: column-flash 0.2s ease-out forwards; }
        .pulse-column::after { bottom: 0; height: 25%; background: linear-gradient( to bottom, transparent 0%, var(--pulse-color) 50%, transparent 100% ); animation: column-wave var(--pulse-duration) cubic-bezier(0.2, 0.8, 0.2, 1) forwards; }
        #notes-container { position: absolute; width: 100%; height: 100%; bottom: 0; left: 0; transition: transform 0.1s linear, filter 0.5s ease-in-out; z-index: 2; }
        
        /* MODIFIED: Removed overflow:hidden to allow labels to clip */
        .note-visual { position: absolute; border-radius: 4px; box-sizing: border-box; opacity: 0; transform: scale(0.6) translateY(10px); transition: opacity 0.4s cubic-bezier(0.64, 0.57, 0.67, 1.57), transform 0.4s cubic-bezier(0.64, 0.57, 0.67, 1.57); }
        .note-visual.visible { opacity: 1; transform: scale(1) translateY(0); }
        .note-visual::after { content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background-color: rgba(255, 255, 255, 0.8); opacity: 0; border-radius: 4px; }
        body.dark-mode .note-visual::after { background-color: rgba(40, 42, 54, 0.8); }
        .note-visual.active-visual::after { animation: note-pulse-wipe 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards; }
        
        /* MODIFIED: Switched to 'outline' property to ensure correct layering */
        .note-visual[class*="outline-"] {
            outline-style: solid;
            outline-width: var(--note-outline-width);
            outline-color: var(--note-specific-outline-color, var(--note-outline-color));
        }
        .note-visual.outline-inward {
            outline-offset: calc(-1 * var(--note-outline-width));
        }
        .note-visual.outline-outward {
            /* This is default behavior, but explicit for clarity */
            outline-offset: 0;
        }
        .note-visual.outline-center {
            outline-offset: calc(-0.5 * var(--note-outline-width));
        }

        .note-visual.pending { opacity: 0.15; }
        .note-visual.missed {
            opacity: 0.35 !important;
            background-color: #7a828e !important;
            transition: background-color 0.3s, opacity 0.3s;
            --note-specific-outline-color: #5c6470 !important;
        }
        .note-visual.hit { pointer-events: none; }

        .piano-key { border: 1px solid var(--piano-outline-color); box-sizing: border-box; position: relative; transition: border-color 0.3s ease, background-color 0.3s; }
        body.piano-outline-hidden .piano-key { border-color: transparent; }
        
       .key-pulse-visual {
            position: absolute;
            left: 0; top: 0; width: 100%; height: 100%;
            pointer-events: none;
            animation: pulse-effect forwards;
        }

        .piano-key.guided { opacity: var(--guidance-opacity); transition: opacity 0.3s; }
        .piano-key.guided.guidance-style-glow { animation: key-guidance-glow 1.5s infinite ease-in-out; }
        .piano-key.guided.guidance-style-outline { animation: key-guidance-outline 1.5s infinite ease-in-out; }

        .white-key { flex-grow: 1; background-color: #ffffff; }
        .black-key { position: absolute; width: calc((100% / 52) * 0.6); height: 60%; background-color: #3d4a5c; z-index: 2; border: none; border-radius: 0 0 3px 3px;}
        
        #controls { flex-shrink: 0; padding-top: 20px; display: grid; grid-template-columns: 1fr auto 1fr; gap: 15px; align-items: center; }
        #seek-bar { grid-column: 1 / -1; }
        .playback-controls { display: flex; justify-content: center; gap: 10px; }
        .time-volume-controls { display: flex; align-items: center; justify-content: flex-end; gap: 15px; }
        .icon-btn { background: none; border: none; cursor: pointer; padding: 8px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: background-color 0.2s; }
        .icon-btn:hover { background-color: #e8eaed; }
        .icon-btn svg { width: 24px; height: 24px; fill: var(--text-color); transition: fill 0.3s; }
        .icon-btn:disabled svg { fill: #b0b8c4; }
        #volume-control { display: flex; align-items: center; gap: 8px; }
        #time-display { font-variant-numeric: tabular-nums; color: var(--text-light-color); }
        
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: #e8eaed; border-radius: 3px; outline: none; transition: background-color 0.3s; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--accent-color); border-radius: 50%; cursor: pointer; transform: scale(1); transition: background-color 0.2s, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        input[type="range"]::-moz-range-thumb { width: 16px; height: 16px; background: var(--accent-color); border-radius: 50%; cursor: pointer; border: none; transform: scale(1); transition: background-color 0.2s, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        input[type="range"]:hover::-webkit-slider-thumb { transform: scale(1.15); }
        input[type="range"]:hover::-moz-range-thumb { transform: scale(1.15); }
        input[type="range"]:active::-webkit-slider-thumb { transform: scale(1.25); background-color: var(--accent-hover-color); }
        input[type="range"]:active::-moz-range-thumb { transform: scale(1.25); background-color: var(--accent-hover-color); }

        input[type="checkbox"].toggle { -webkit-appearance: none; appearance: none; position: relative; width: 40px; height: 22px; background-color: #ccd6e0; border-radius: 11px; vertical-align: middle; cursor: pointer; outline: none; transition: background-color 0.2s ease-in-out; }
        input[type="checkbox"].toggle::after { content: ''; position: absolute; top: 2px; left: 2px; width: 18px; height: 18px; background-color: white; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: transform 0.2s ease-in-out; }
        input[type="checkbox"].toggle:checked { background-color: var(--accent-color); }
        input[type="checkbox"].toggle:checked::after { transform: translateX(18px); }

        .panel { background-color: #fff; border: 1px solid var(--border-color); border-radius: 12px; transition: background-color 0.3s, border-color 0.3s; }
        .panel h3 { margin: 0; font-size: 1em; color: var(--text-color); transition: color 0.3s; }
        .panel .panel-header { padding: 15px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; user-select: none; transition: border-color 0.3s; }
        .panel .toggle-icon { font-family: monospace; font-weight: bold; margin-right: 8px; width: 1.2em; text-align: center; }
        .panel .panel-content { display: grid; grid-template-rows: 1fr; transition: grid-template-rows 0.35s ease-in-out; }
        .panel.minimized .panel-content { grid-template-rows: 0fr; }
        .panel-content-inner { overflow: hidden; min-height: 0; padding: 15px; }
        .panel.minimized .panel-header { border-bottom-color: transparent; }
        .panel.minimized .panel-content-inner { padding-top: 0; padding-bottom: 0; }

.drop-zone .panel-content-inner {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            padding-bottom: 25px;
        }

        .drop-zone.dragover .panel-content-inner { background-color: #e8f0fe; border-color: var(--accent-color); }
        .drop-zone p { margin: 0; color: var(--text-light-color); }
        .btn { display: inline-block; background-color: var(--accent-color); color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; margin-top: 10px; }
        .btn:hover:not(:disabled) { background-color: var(--accent-hover-color); }
        .btn:disabled { background-color: #b0b8c4; cursor: not-allowed; }
        input[type="file"] { display: none; }
        
        .settings-list { list-style: none; padding: 0; margin: 0; font-size: 0.9em; }
        .settings-list li { display: flex; flex-wrap: wrap; justify-content: space-between; align-items:center; padding: 5px 0; transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out, margin 0.3s ease-in-out; overflow: hidden; max-height: 50px;}
        .settings-list li.sub-item-hidden { max-height: 0; opacity: 0; padding: 0; margin: 0; pointer-events: none;}
        .settings-list span { color: var(--text-light-color); }
        .settings-list label, .keybind-item label { flex-grow: 1; }
        .settings-list .mini-section-header { color: var(--text-color); font-weight: 600; font-size: 0.8em; text-transform: uppercase; padding: 15px 0 5px; display: block; border-bottom: 1px solid var(--border-color); margin-bottom: 5px; width: 100%; transition: border-color 0.3s, color 0.3s; cursor: pointer; user-select: none; }
        .settings-list .mini-section-header:first-child { padding-top: 0; }
        /* NEW: Toggle icon for collapsible mini-sections */
        .settings-list .mini-section-header .toggle-icon { display: inline-block; width: 1em; font-family: monospace; font-weight: bold; }

        #channel-mixer-list { list-style: none; padding: 0; margin: 0; font-size: 0.9em; max-height: 150px; overflow-y: auto; }
        #channel-mixer-list li { display: grid; grid-template-columns: auto auto 1fr auto auto; gap: 8px; align-items: center; padding: 5px; border-radius: 6px; transition: background-color 0.2s; }
        #channel-mixer-list li.dragging { opacity: 0.5; background: var(--accent-color); }
        #channel-mixer-list li:hover { background-color: #f4f7fa; }
        /* NEW: Drag handle for channel mixer */
        .drag-handle { cursor: grab; padding: 0 5px; color: var(--text-light-color); }
        .drag-handle:active { cursor: grabbing; }
        
        #channel-mixer-list input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 24px; height: 24px; background-color: transparent; border: none; cursor: pointer; padding: 0; }
        #channel-mixer-list input[type="color"]::-webkit-color-swatch { border-radius: 4px; border: 1px solid var(--border-color); transition: border-color 0.3s;}
        #channel-mixer-list input[type="color"]::-moz-color-swatch { border-radius: 4px; border: 1px solid var(--border-color); transition: border-color 0.3s; }

        .channel-settings-btn { background: none; border: none; cursor: pointer; padding: 0; font-size: 1.2em; line-height: 1; color: var(--text-light-color); transition: color 0.2s; }
        .channel-settings-btn:hover { color: var(--text-color); }
        
        #keybind-settings-list { display: flex; flex-direction: column; gap: 8px; }
        .keybind-item { display: grid; grid-template-columns: 1fr auto; align-items: center; padding: 4px; border-radius: 4px; transition: background-color 0.2s; }
        .keybind-item:hover { background-color: #f4f7fa; }
        .keybind-btn { background-color: #f0f2f5; border: 1px solid var(--border-color); padding: 4px 12px; border-radius: 6px; cursor: pointer; font-family: monospace; min-width: 80px; text-align: center; transition: background-color 0.2s, border-color 0.2s; }
        .keybind-btn:hover { background-color: #e8eaed; }
        .keybind-btn.listening { background-color: var(--accent-color); color: white; border-color: var(--accent-hover-color); }

        #theme-editor input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; background-color: transparent; border: none; cursor: pointer; padding: 0; width: 30px; height: 30px; }
        #theme-editor input[type="color"]::-webkit-color-swatch { border-radius: 6px; border: 1px solid var(--border-color); transition: border-color 0.3s;}
        #theme-editor input[type="color"]::-moz-color-swatch { border-radius: 6px; border: 1px solid var(--border-color); transition: border-color 0.3s;}
        
        .loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.7); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; transition: opacity 0.2s; pointer-events: none; }
        body.dark-mode .loading-overlay { background: rgba(26, 27, 38, 0.7); }
        .loading-overlay.visible { opacity: 1; pointer-events: auto; }
        .loading-spinner { color: var(--text-light-color); }
        
        .panel-content-inner select { width: auto; min-width: 120px; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background-color: #f8fafd; font-family: 'Poppins', sans-serif; font-size: 0.9em; color: var(--text-color); transition: background-color 0.3s, border-color 0.3s, color 0.3s; }
        #midi-input-panel .panel-content-inner label { display: block; margin-bottom: 5px; color: var(--text-light-color); }
        #midi-input-panel .panel-content-inner p { margin: 10px 0 0 0; font-size: 0.85em; }
        #visual-aids-panel .settings-list select, #theme-editor .settings-list select { width: auto; min-width: 120px; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background-color: #f8fafd; font-family: 'Poppins', sans-serif; font-size: 0.9em; color: var(--text-color); transition: background-color 0.3s, border-color 0.3s, color 0.3s; -webkit-appearance: none; appearance: none; }
        
        #debug-toggle { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.5); color: white; padding: 4px 8px; font-family: monospace; font-size: 0.8em; border-radius: 4px; cursor: pointer; z-index: 15; user-select: none; display: none; }
        #debug-stats { position: absolute; top: 35px; left: 10px; background: rgba(0,0,0,0.6); color: #f0f0f0; padding: 10px; font-family: monospace; font-size: 0.85em; line-height: 1.5; border-radius: 6px; z-index: 15; pointer-events: none; display: none; }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 200; opacity: 0; pointer-events: none; transition: opacity 0.25s ease-in-out; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background: var(--app-bg); padding: 20px; border-radius: 12px; box-shadow: 0 5px 25px rgba(0,0,0,0.2); width: 90%; max-width: 500px; transform: scale(0.9); transition: transform 0.25s ease-in-out, background-color 0.3s; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; transition: border-color 0.3s; }
        .modal-header h2 { margin: 0; font-size: 1.2em; }
        .modal-close { background: none; border: none; font-size: 1.8em; cursor: pointer; line-height: 1; color: var(--text-light-color); }
        .modal-body .setting-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; }
        .modal-body label { font-weight: 500; }
        #drum-map-display { margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border-color); transition: border-color 0.3s;}
        #drum-map-display h3 { margin: 0 0 10px 0; font-size: 1em; color: var(--text-color); }
        #drum-map-display ul { list-style: none; padding: 0; margin: 0; font-size: 0.8em; max-height: 150px; overflow-y: auto; color: var(--text-light-color); }
        #drum-map-display li { display: grid; grid-template-columns: 60px 1fr; padding: 2px 5px; border-radius: 4px; }
        #drum-map-display li:nth-child(odd) { background-color: #f8fafd; transition: background-color 0.3s; }
        #drum-map-display li strong { font-family: monospace; color: var(--text-color); }
        .modal-footer { display: flex; justify-content: flex-end; gap: 15px; padding-top: 20px; margin-top: 10px; border-top: 1px solid var(--border-color); transition: border-color 0.3s;}
        
        #game-hud { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; color: var(--text-color); opacity: 0.8; font-size: 1.5em; text-shadow: 0 1px 2px rgba(255,255,255,0.5); text-align: center; pointer-events: none; }
        body.dark-mode #game-hud { text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
        #score-display { font-weight: 600; }
        #combo-display { font-size: 1.8em; font-weight: bold; margin-top: 5px; opacity: 0; transform: scale(0.8); transition: opacity 0.2s, transform 0.2s; }
        #combo-display.visible { opacity: 1; transform: scale(1); }
        #judgement-text { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); z-index: 11; font-size: 2.5em; font-weight: bold; opacity: 0; pointer-events: none; text-shadow: 0 2px 5px rgba(0,0,0,0.25); }

        #results-overlay .modal-body .result-item { display: flex; justify-content: space-between; padding: 8px 0; font-size: 1.1em; }
        #results-overlay .modal-body .result-item span:first-child { color: var(--text-light-color); }
        #results-overlay .modal-body .result-item span:last-child { font-weight: 600; }
        #results-overlay hr { border: none; border-top: 1px solid var(--border-color); margin: 10px 0; }
        #results-overlay .modal-footer { display: flex; justify-content: flex-end; gap: 15px; padding-top: 20px; margin-top: 10px; border-top: 1px solid var(--border-color); }
        #restart-game-btn { background-color: var(--text-light-color); }
        #restart-game-btn:hover { background-color: var(--text-color); }

        #sync-visualizer {
            position: relative; height: 60px;
            background-color: var(--piano-bg);
            border: none;
            border-radius: 8px; margin: 10px 0 20px; overflow: hidden;
            transition: background-color 0.3s, border-color 0.3s;
            display: flex; align-items: center; justify-content: center;
        }
        #sync-bar {
            position: absolute; top: 0; left: 0;
            height: 100%; width: 0%;
            background-color: var(--accent-color);
            opacity: 0.2;
        }
        #sync-marker {
            display: none;
            position: absolute; top: 0; left: 80%;
            width: 4px; height: 100%;
            background-color: var(--hit-line-color);
            transform: translateX(-50%);
            border-radius: 2px;
        }
        #sync-marker.hit { animation: sync-marker-hit 0.2s ease-out; }
        
        #sync-results {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 20px; font-size: 0.9em;
            margin-top: 15px; align-items: center;
        }
        #sync-plot-container {
            border-left: 1px solid var(--border-color);
            padding-left: 20px; height: 100px;
        }
        #sync-plot { width: 100%; height: 100%; }
        #sync-plot line { stroke: var(--border-color); stroke-width: 1; }
        #sync-plot .center-line { stroke: var(--text-color); stroke-dasharray: 4 4; }
        #sync-plot circle {
            fill: var(--accent-color); stroke: var(--app-bg);
            stroke-width: 2; opacity: 0.8;
            transition: transform 0.2s ease-out;
        }
        #sync-results-summary p { margin: 5px 0; }
        #sync-results-summary strong {
            font-size: 1.2em;
            color: var(--text-color);
            min-width: 60px; display: inline-block;
        }
        .btn-secondary { background-color: var(--text-light-color); }
        .btn-secondary:hover { background-color: var(--text-color); }
        .btn-go { background-color: #4CAF50; }
        .btn-go:hover { background-color: #45a049; }
        
        #countdown-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            z-index: 12;
            pointer-events: none;
        }
        #countdown-text {
            font-size: 10em; font-weight: bold;
            color: var(--accent-color);
            text-shadow: 0 5px 15px rgba(0,0,0,0.2);
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
        }
        .countdown-pop-animation {
            animation: countdown-pop 0.9s ease-out forwards;
        }

        #grid-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        body.grid-mode-active #grid-container {
            opacity: 1;
        }
        .grid-line {
            position: absolute;
            top: 0;
            height: 100%;
            width: 1px;
            background-color: var(--border-color);
            opacity: 0.5;
        }
        .grid-black-key-area {
            position: absolute;
            top: 0;
            height: 100%;
            background-color: var(--border-color);
            opacity: var(--grid-black-key-opacity);
        }
        body.dark-mode .grid-line,
        body.dark-mode .grid-black-key-area {
            background-color: var(--dark-border-color);
        }
        body.dark-mode .grid-line {
            opacity: 0.4;
        }

        .note-label {
            position: absolute;
            font-size: 10px;
            font-weight: 600;
            user-select: none;
            white-space: nowrap;
            color: var(--note-label-fill-color);
            text-shadow:
                -1px -1px 0 var(--note-label-outline-color),
                 1px -1px 0 var(--note-label-outline-color),
                -1px  1px 0 var(--note-label-outline-color),
                 1px  1px 0 var(--note-label-outline-color);
        }
        .note-label-pos-top { top: 2px; }
        .note-label-pos-middle { top: 50%; }
        .note-label-pos-bottom { bottom: 2px; }
        .note-label-horizontal {
            left: 50%;
            transform: translateX(-50%);
        }
        .note-label-horizontal.note-label-pos-middle { transform: translate(-50%, -50%); }
        .note-label-vertical {
            left: 50%;
            transform-origin: center;
            transform: translateX(-50%) rotate(-90deg);
        }
        .note-label-vertical.note-label-pos-middle { transform: translate(-50%, -50%) rotate(-90deg); }

        /* --- MODIFIED: MIDI Pack Styles --- */
        #midi-packs-list {
            list-style: none;
            padding: 0;
            margin: 15px 0 0 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .midipack-item {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            transition: border-color 0.3s, border-left-color 0.3s;
        }
        .midipack-header {
            padding: 10px 12px;
            cursor: pointer;
            background-color: #f8fafd;
            transition: background-color 0.2s, background-image 0.3s;
            user-select: none;
            position: relative;
        }
        .midipack-header:hover {
            background-color: #f0f3f7;
        }
        .midipack-title {
            font-weight: 600;
            font-size: 0.95em;
            margin: 0;
        }
        .midipack-description {
            font-size: 0.8em;
            color: var(--text-light-color);
            margin: 2px 0 0 0;
        }
        .midipack-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8em;
            color: var(--text-light-color);
            margin-top: 8px;
        }
        .difficulty-stars {
            color: #f5c542;
            letter-spacing: 1px;
            font-size: 1.1em;
            vertical-align: middle;
        }
        .difficulty-stars .empty-star {
            color: var(--border-color);
        }
        .difficulty-stars .half-star {
            display: inline-block;
            color: var(--border-color);
            position: relative;
        }
        .difficulty-stars .half-star::before {
            content: '★';
            color: #f5c542;
            position: absolute;
            left: 0;
            top: 0;
            width: 50%;
            overflow: hidden;
        }
        .midipack-songlist-container {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.3s ease-in-out;
        }
        .midipack-item.expanded .midipack-songlist-container {
             grid-template-rows: 1fr;
        }
        .midipack-songlist-inner {
             overflow: hidden;
        }
        .midipack-songlist {
            list-style: none;
            padding: 5px;
            margin: 0;
            max-height: 140px;
            overflow-y: auto;
        }
        .midipack-songlist::-webkit-scrollbar { width: 6px; }
        .midipack-songlist::-webkit-scrollbar-track { background: transparent; }
        .midipack-songlist::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 3px; }
        .midipack-songlist::-webkit-scrollbar-thumb:hover { background-color: var(--text-light-color); }

        .midipack-song-item {
            padding: 8px 10px;
            font-size: 0.85em;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .song-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .song-note-count {
            font-size: 0.9em;
            color: var(--text-light-color);
            flex-shrink: 0;
            margin-left: 10px;
        }
        .midipack-song-item:hover {
            background-color: #f4f7fa;
        }

        /* --- NEW: Keyboard Rhythm Game Styles --- */
        #keyboard-game-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5;
            display: none; /* Hidden by default */
            flex-direction: column;
            background-color: var(--piano-bg);
        }
        #kb-game-lanes-container {
            flex-grow: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        .kb-game-lane {
            flex: 1;
            border-left: 1px solid var(--border-color);
            position: relative;
        }
        .kb-game-lane:last-child {
            border-right: 1px solid var(--border-color);
        }
        #kb-game-notes-container {
            position: absolute;
            width: 100%; height: 100%;
            bottom: 0; left: 0;
            transition: transform 0.1s linear;
        }
        .kb-game-note {
            position: absolute;
            box-sizing: border-box;
            border-radius: 5px;
            transition: opacity 0.2s, background-color 0.2s, transform 0.1s;
        }
        .kb-game-note.hold::after {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(255,255,255,0.4), rgba(255,255,255,0.1) 20%, transparent 50%, rgba(255,255,255,0.1) 80%, rgba(255,255,255,0.4));
            border-radius: 5px;
        }
        .kb-game-note.pending { opacity: 0.3; }
        .kb-game-note.missed { background-color: #7a828e !important; opacity: 0.5; }
        .kb-game-note.hit { opacity: 0; pointer-events: none; transition: opacity 0.1s; }

        /* MODIFIED */
        .kb-game-note.active-hold {
            box-shadow: 0 0 15px 3px var(--glow-color, var(--accent-color)), inset 0 0 10px rgba(255,255,255,0.5);
            transform: scale(1.02);
            opacity: 1 !important;
        }

        #kb-game-hit-zone {
            flex-shrink: 0;
            height: 80px;
            background-color: var(--app-bg);
            border-top: 3px solid var(--hit-line-color);
            display: flex;
            padding: 10px;
            gap: 10px;
        }
        .kb-key-indicator {
            flex: 1;
            border-radius: 8px;
            background-color: var(--piano-bg);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: 600;
            color: var(--text-color);
            box-shadow: inset 0 -4px 0 rgba(0,0,0,0.15);
            /* MODIFIED: Added background-color and color to the transition */
            transition: transform 0.05s, box-shadow 0.05s, background-color 0.1s, color 0.1s;
        }
        .kb-key-indicator.pressed {
            animation: kb-key-press 0.1s forwards;
            background-color: var(--accent-color);
            color: #fff;
        }

        /* --- NEW: Game Mode Choice Modal --- */
        #game-mode-choice-modal .modal-body {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .game-mode-option-btn {
            width: 100%;
            padding: 20px;
            font-size: 1.1em;
            box-sizing: border-box;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .game-mode-option-btn svg {
            width: 32px;
            height: 32px;
            fill: #fff;
            flex-shrink: 0;
        }

        /* --- MODIFIED: Reworked styles for a more robust vertical layout --- */
        .settings-list li.full-width-control {
            display: block;
            padding-top: 5px;
            /* MODIFIED: Increased bottom padding to add more vertical space */
            padding-bottom: 15px;
        }
        .settings-list li.full-width-control label {
            display: block;
            margin-bottom: 8px; /* Space between label and control */
        }
        .settings-list li.full-width-control select {
            width: 100%;
            box-sizing: border-box;
            padding: 10px 12px;
            font-size: 0.9em;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--piano-bg);
            color: var(--text-color);
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%233d4a5c'%3E%3Cpath d='M7,10L12,15L17,10H7Z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 24px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            /* MODIFIED: Removed margin-bottom to rely on parent padding for consistent spacing */
            margin-bottom: 0;
        }

        .settings-list li.full-width-control select:hover {
            border-color: var(--accent-color);
        }
        body.dark-mode .settings-list li.full-width-control select {
            background-color: var(--dark-aside-bg);
            border-color: var(--dark-border-color);
            color: var(--dark-text-color);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23c0caf5'%3E%3Cpath d='M7,10L12,15L17,10H7Z'/%3E%3C/svg%3E");
        }

         /* --- NEW: UI Styles for Settings Controls --- */
        .control-container {
            display: flex;
            align-items: center;
            gap: 12px;
            /* MODIFIED: Removed fixed width to allow it to fill the parent */
            width: 100%; 
            justify-content: flex-end;
        }
        /* ... */
        /* --- NEW: Styles for Full-Width Controls --- */
        .settings-list li.full-width-control {
            display: block;
            padding-top: 5px;
            padding-bottom: 20px;
        }
        .settings-list li.full-width-control label {
            display: block;
            margin-bottom: 8px; /* Space between label and control */
        }
        .settings-list li.full-width-control select {
            width: 100%;
            box-sizing: border-box;
            padding: 10px 12px;
            font-size: 0.9em;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--piano-bg);
            color: var(--text-color);
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%233d4a5c'%3E%3Cpath d='M7,10L12,15L17,10H7Z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 24px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            margin-bottom: 0;
        }
        /* --- NEW RULE ADDED HERE --- */
        .settings-list li.full-width-control + li {
            margin-top: 5px; /* Adds space above the "Color Keys On Press" toggle */
        }

        /* --- REVISED: Tutorial Styles --- */
        #tutorial-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: auto;
            padding-top: 15px;
            flex-shrink: 0;
        }

        #watermark {
            margin-top: 0;
            padding-top: 0;
        }

        #tutorial-icon {
            cursor: pointer;
            color: var(--text-light-color);
            transition: color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
            border-radius: 50%;
        }
        #tutorial-icon:hover {
            color: var(--accent-color);
            background-color: var(--piano-bg);
            transform: scale(1.1);
        }
        #tutorial-icon svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(2px);
            opacity: 0;
            pointer-events: none;
            /* Uses clip-path to create a "hole" silhouette */
            clip-path: polygon(evenodd,
                0% 0%, 0% 100%, 100% 100%, 100% 0%, 0% 0%,
                50% 50%, 50% 50%, 50% 50%, 50% 50%
            );
            transition: clip-path 0.25s ease-in-out, opacity 0.3s ease-in-out, backdrop-filter 0.3s ease-in-out;
        }
        #tutorial-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .tutorial-caption-box {
            position: fixed;
            background-color: var(--app-bg);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
            width: 90%;
            max-width: 350px;
            z-index: 1001;
            opacity: 0;
            transform: translateY(10px) scale(0.98);
            transition: opacity 0.15s ease-out, transform 0.15s ease-out;
        }
        #tutorial-overlay.visible .tutorial-caption-box.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .tutorial-caption-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        .tutorial-caption-header h4 {
            margin: 0;
            font-size: 1.1em;
            color: var(--text-color);
        }
        .tutorial-caption-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            line-height: 1;
            color: var(--text-light-color);
            padding: 4px 8px;
            border-radius: 50%;
            transition: background-color 0.2s, color 0.2s;
        }
        .tutorial-caption-close:hover {
            background-color: var(--piano-bg);
            color: var(--text-color);
        }

        .tutorial-caption-body p {
            margin: 0;
            font-size: 0.9em;
            color: var(--text-light-color);
            line-height: 1.6;
        }

        .tutorial-caption-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }
        .tutorial-step-counter {
            font-size: 0.8em;
            color: var(--text-light-color);
        }
        .tutorial-nav-btns {
            display: flex;
            gap: 10px;
        }
        /* Make nav buttons a bit smaller for the tutorial box */
        .tutorial-nav-btns .btn {
            padding: 6px 16px;
            font-size: 0.9em;
        }
        #tutorial-prev-btn {
            background-color: transparent;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
         #tutorial-prev-btn:hover {
            background-color: var(--piano-bg);
            border-color: var(--accent-color);
        }


    </style>
</head>
<body>

    <div id="app-container">
        <main>
            <div id="visual-engine">
                <div id="countdown-overlay" style="display: none;">
                    <span id="countdown-text"></span>
                </div>

                <!-- MOVED HUD AND JUDGEMENT TO HERE -->
                <div id="game-hud" style="display: none;">
                    <div id="score-display">Score: 0</div>
                    <div id="combo-display"></div>
                </div>
                <div id="judgement-text"></div>

                <div id="keyboard-game-container">
                    <div id="kb-game-lanes-container">
                         <div id="kb-game-notes-container"></div>
                    </div>
                    <div id="kb-game-hit-zone"></div>
                </div>

                <div id="visualizer-wrapper">
                    <div id="grid-container"></div>
                    <div id="dim-overlay"></div>
                    <div id="debug-toggle">DEBUG</div>
                    <div id="debug-stats"></div>
                    
                    <!-- HUD and Judgement Text were removed from here -->

                    <div id="loading-fx-container">
                        <svg id="loading-ribbon-svg" viewBox="0 0 800 300" preserveAspectRatio="xMidYMid meet">
                            <path id="loading-ribbon-path" d="M -50,150 Q 150,50 400,150 T 850,150"></path>
                        </svg>
                        <div class="blur-shape blur-shape-1"></div>
                        <div class="blur-shape blur-shape-2"></div>
                        <div id="loading-text"></div>
                    </div>
                    <div id="pulse-container"></div>
                    <div id="notes-container"></div>
                    <div id="loading-overlay" class="loading-overlay">
                        <span class="loading-spinner">Loading...</span>
                    </div>
                </div>
                <div id="piano-container"></div>
            </div>
            <div id="controls">
                <input type="range" id="seek-bar" value="0" step="0.1" disabled>
                <div class="time-volume-controls" style="justify-content: flex-start;">
                    <div id="time-display">00:00 / 00:00</div>
                </div>
                <div class="playback-controls">
                    <button id="play-pause-btn" class="icon-btn" disabled>
                        <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    </button>
                    <button id="game-mode-btn" class="icon-btn" title="Rhythm Game Mode" disabled>
                        <svg viewBox="0 0 24 24"><path d="M16.5,9H22V15H16.5L13.5,12L16.5,9M7.5,9L10.5,12L7.5,15H2V9H7.5M12,13.5L9,16.5V22H15V16.5L12,13.5M15,7.5L12,10.5L9,7.5V2H15V7.5Z"/></svg>
                    </button>
                </div>
                <div class="time-volume-controls">
                    <div id="accompaniment-volume-control" style="display: none; align-items: center; gap: 8px;" title="Accompaniment (MIDI File) Volume">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="#8a96a8"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
                        <input type="range" id="accompaniment-volume-slider" min="0" max="1" value="0.5" step="0.05">
                    </div>
                    <div id="volume-control" title="Live MIDI Input Volume">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="#8a96a8"><path d="M19,5V19H5V5H19M21,3H3V21H21V3M7,7V13H9V7H7M11,7V13H13V7H11M15,7V13H17V7H15Z" /></svg>
                        <input type="range" id="volume-slider" min="0" max="1.5" value="1.0" step="0.05">
                    </div>
                </div>
            </div>
        </main>
        <aside>
            <div id="tabs-nav">
                <button class="tab-btn active" data-tab="general" title="General">
                    <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81C14.34,2.59,14.13,2.42,13.89,2.42 h-3.79c-0.24,0-0.44,0.17-0.5,0.4L9.22,5.29C8.63,5.53,8.1,5.84,7.6,6.22L5.21,5.26C4.99,5.19,4.74,5.26,4.62,5.48L2.7,8.8 c-0.11,0.2-0.06,0.47,0.12,0.61l2.03,1.58C4.82,11.36,4.8,11.68,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.38,2.48 c0.06,0.23,0.26,0.4,0.5,0.4h3.79c0.24,0,0.44-0.17,0.5-0.4l0.38-2.48c0.59-0.24,1.12-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0.01,0.59-0.22l1.92-3.32c0.12-0.2,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
                </button>
                <button class="tab-btn" data-tab="appearance" title="Appearance">
                    <svg viewBox="0 0 24 24"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>
                </button>
                <button class="tab-btn" data-tab="performance" title="Performance">
                    <svg viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg>
                </button>
                <button class="tab-btn" data-tab="game" title="Game">
                    <svg viewBox="0 0 24 24"><path d="M15,7.5V2H9v5.5l3,3L15,7.5z M7.5,9H2v6h5.5l3-3L7.5,9z M9,16.5V22h6v-5.5l-3-3L9,16.5z M16.5,9l-3,3l3,3H22V9H16.5z"/></svg>
                </button>
            </div>
            <div id="aside-scroll-wrapper">
                <div id="tab-content-general" class="tab-content active">
                    <div class="panel drop-zone">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>Load File</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <p>Drag & Drop a MIDI file here</p>
                                <p>- or -</p>
                                <label for="midi-file-input" class="btn">Select File</label>
                                <input type="file" id="midi-file-input" accept=".mid,.midi">
                            </div>
                        </div>
                    </div>
                    <div id="midi-packs-panel" class="panel">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>MIDI Packs</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <label for="midi-packs-input" class="btn" style="width: 100%; text-align: center; box-sizing: border-box; margin-top: 0;">Select 'midipacks' Folder</label>
                                <input type="file" id="midi-packs-input" webkitdirectory directory>
                                <ul id="midi-packs-list"></ul>
                            </div>
                        </div>
                    </div>
                    <div id="midi-info" class="panel">
                         <h3 class="panel-header"><span class="toggle-icon">[-]</span>MIDI Info</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <ul class="settings-list">
                                    <li><label>Tempo</label><span>-- BPM</span></li>
                                    <li><label>Note Count</label><span>--</span></li>
                                    <li><label>Channels</label><span>--</span></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div id="channel-mixer" class="panel">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>Channel Mixer</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <ul id="channel-mixer-list"></ul>
                            </div>
                        </div>
                    </div>
                     <div id="midi-input-panel" class="panel">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>Live MIDI Input</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <label for="midi-input-select">Select Device:</label>
                                <select id="midi-input-select">
                                    <option>Click to enable MIDI...</option>
                                </select>
                                <p id="midi-status">Status: Waiting for user action.</p>
                            </div>
                        </div>
                    </div>
                    <div id="keybind-settings-panel" class="panel">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>Keybind Settings</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <div id="keybind-settings-list">
                                    </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="tab-content-appearance" class="tab-content">
                    <div id="theme-editor" class="panel">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>Theme & Style</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <ul class="settings-list">
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Theme</li>
                                    <li><label for="dark-mode-toggle">Enable Dark Mode</label><input type="checkbox" id="dark-mode-toggle" class="toggle"></li>
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Colors</li>
                                    <li> <label for="bg-color-input">Page Background</label> <input type="color" id="bg-color-input" data-variable="--bg-color" data-dark-variable="--dark-bg-color" value="#f4f7fa"> </li>
                                    <li> <label for="app-bg-input">App Background</label> <input type="color" id="app-bg-input" data-variable="--app-bg" data-dark-variable="--dark-app-bg" value="#ffffff"> </li>
                                    <li> <label for="piano-bg-input">Visualizer BG</label> <input type="color" id="piano-bg-input" data-variable="--piano-bg" data-dark-variable="--dark-piano-bg" value="#eef1f5"> </li>
                                    <li> <label for="text-color-input">Text</label> <input type="color" id="text-color-input" data-variable="--text-color" data-dark-variable="--dark-text-color" value="#3d4a5c"> </li>
                                    <li> <label for="accent-color-input">Accent</label> <input type="color" id="accent-color-input" data-variable="--accent-color" data-dark-variable="--dark-accent-color" value="#5e81f4"> </li>
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Hit Line</li>
                                    <li> <label for="hit-line-color-input">Hit Line Color</label> <input type="color" id="hit-line-color-input" data-variable="--hit-line-color" data-dark-variable="--dark-hit-line-color" value="#ff7b7b"> </li>
                                    <li> <label for="hit-line-toggle">Show Hit Line</label> <input type="checkbox" id="hit-line-toggle" class="toggle" checked> </li>
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Piano Outline</li>
                                    <li> <label for="piano-outline-color-input">Piano Outline Color</label> <input type="color" id="piano-outline-color-input" data-variable="--piano-outline-color" data-dark-variable="--dark-piano-outline-color" value="#d1d5db"> </li>
                                    <li> <label for="piano-outline-toggle">Show Piano Outline</label> <input type="checkbox" id="piano-outline-toggle" class="toggle" checked> </li>
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Column Pulse</li>
                                    <li> <label for="pulse-toggle">Enable Column Pulse</label> <input type="checkbox" id="pulse-toggle" class="toggle" checked> </li>
                                    <li> <label for="pulse-color-toggle">Use Note Color</label> <input type="checkbox" id="pulse-color-toggle" class="toggle"> </li>
                                    <li> <label for="pulse-color-input">Custom Color</label> <input type="color" id="pulse-color-input" value="#ffffff"> </li>
                                    <li><label for="divided-pulse-toggle">Enable Divided Key Pulse</label><input type="checkbox" id="divided-pulse-toggle" class="toggle"></li>
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Note Outlines</li>
                                    <li><label for="note-outline-toggle">Enable Note Outlines</label><input type="checkbox" id="note-outline-toggle" class="toggle"></li>
                                    <li>
                                        <label for="note-outline-style-select">Outline Style</label>
                                        <select id="note-outline-style-select">
                                            <option value="inward" selected>Inward</option>
                                            <option value="outward">Outward</option>
                                            <option value="center">Center</option>
                                        </select>
                                    </li>
                                    <li><label for="note-outline-width-slider">Outline Width</label><input type="range" id="note-outline-width-slider" min="1" max="5" value="1" step="0.5"></li>
                                    <li><label for="note-outline-auto-color-toggle">Automatic Color</label><input type="checkbox" id="note-outline-auto-color-toggle" class="toggle" checked></li>
                                    <li><label for="note-outline-color-input">Outline Color</label><input type="color" id="note-outline-color-input" data-variable="--note-outline-color" data-dark-variable="--dark-note-outline-color" value="#000000"></li>
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Note Labels</li>
                                    <li><label for="note-label-toggle">Enable Note Labels</label><input type="checkbox" id="note-label-toggle" class="toggle"></li>
                                    <li>
                                        <label for="note-label-orientation-select">Label Orientation</label>
                                        <select id="note-label-orientation-select">
                                            <option value="horizontal" selected>Horizontal</option>
                                            <option value="vertical">Vertical</option>
                                        </select>
                                    </li>
                                    <li>
                                        <label for="note-label-position-select">Label Position</label>
                                        <select id="note-label-position-select">
                                            <option value="top">Top</option>
                                            <option value="middle" selected>Middle</option>
                                            <option value="bottom">Bottom</option>
                                        </select>
                                    </li>
                                    <li><label for="note-label-octave-toggle">Show Octave Number</label><input type="checkbox" id="note-label-octave-toggle" class="toggle" checked></li>
                                    <li><label for="note-label-custom-color-toggle">Automatic Color</label><input type="checkbox" id="note-label-custom-color-toggle" class="toggle" checked></li>
                                    <li><label for="note-label-fill-color">Label Color</label><input type="color" id="note-label-fill-color" data-variable="--note-label-fill-color" data-dark-variable="--dark-note-label-fill-color" value="#ffffff"></li>
                                    <li><label for="note-label-outline-color">Label Outline Color</label><input type="color" id="note-label-outline-color" data-variable="--note-label-outline-color" data-dark-variable="--dark-note-label-outline-color" value="#000000"></li>
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Loading Animation</li>
                                    <li> <label for="loading-ribbon-toggle">Show Squiggly Ribbon</label> <input type="checkbox" id="loading-ribbon-toggle" class="toggle"> </li>
                                    <li> <label for="loading-ribbon-thickness">Ribbon Thickness</label> <input type="range" id="loading-ribbon-thickness" min="2" max="20" value="8" step="1"> </li>
                                    <li> <label for="loading-blur-toggle">Enable Background Blur</label> <input type="checkbox" id="loading-blur-toggle" class="toggle" checked> </li>
                                    <li> <label for="loading-blur-amount">Blur Amount</label> <input type="range" id="loading-blur-amount" min="0" max="15" value="5" step="1"> </li>
                                    <li><label for="note-reveal-anim-toggle">Enable Note Reveal Animation</label><input type="checkbox" id="note-reveal-anim-toggle" class="toggle" checked></li>
                                    <li><label for="note-reveal-duration-slider">Reveal Duration (ms)</label><input type="range" id="note-reveal-duration-slider" min="500" max="5000" value="2500" step="100"></li>
                                    <li><label for="note-reveal-opacity-slider">Dim Opacity</label><input type="range" id="note-reveal-opacity-slider" min="0" max="80" value="25" step="1"></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                     <div id="visual-aids-panel" class="panel">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>Visual Aids</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                 <ul class="settings-list">
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Guidance Mode</li>
                                    <li><label for="guidance-mode-toggle">Enable Guidance Mode</label><input type="checkbox" id="guidance-mode-toggle" class="toggle"></li>
                                    <li>
                                        <label for="guidance-style-select">Guidance Style</label>
                                        <select id="guidance-style-select">
                                            <option value="glow" selected>Glow</option>
                                            <option value="outline">Outline</option>
                                        </select>
                                    </li>
                                    <li> <label for="guidance-color-input">Guidance Color</label> <input type="color" id="guidance-color-input" data-variable="--guidance-color" data-dark-variable="--dark-guidance-color" value="#5e81f4"> </li>
                                    <li><label for="guidance-opacity-slider">Guidance Opacity</label><input type="range" id="guidance-opacity-slider" min="10" max="100" value="100" step="5"></li>
                                    <li><label for="pulse-opacity-slider">Pulse Opacity</label><input type="range" id="pulse-opacity-slider" min="10" max="100" value="100" step="5"></li>
                                    <li class="mini-section-header" style="margin-top:10px;"><span class="toggle-icon">[-]</span>Grid</li>
                                    <li><label for="grid-mode-toggle">Enable Column Grid</label><input type="checkbox" id="grid-mode-toggle" class="toggle"></li>
                                    <li><label for="grid-shading-slider">Black Key Shading</label><input type="range" id="grid-shading-slider" min="0" max="50" value="5" step="1"></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="tab-content-performance" class="tab-content">
                    <div id="performance-settings" class="panel">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>Performance Settings</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <ul class="settings-list">
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Animation</li>
                                    <li> <label for="note-speed-slider">Note Fall Speed</label> <input type="range" id="note-speed-slider" min="50" max="1000" value="550" step="10"> </li>
                                    <li> <label for="pulse-duration-slider">Pulse Duration</label> <input type="range" id="pulse-duration-slider" min="0.5" max="3" value="1.2" step="0.1"> </li>
                                    <li style="margin-top: 10px;"> <label for="less-lag-toggle">Enable Low Lag Mode</label> <input type="checkbox" id="less-lag-toggle" class="toggle" checked> </li>
                                    <li style="margin-top: 10px;">
                                        <label for="preroll-toggle">Enable Pre-Roll (Normal Mode)</label>
                                        <input type="checkbox" id="preroll-toggle" class="toggle">
                                    </li>
                                    <li class="mini-section-header" style="padding-top: 15px; margin-top: 10px;"><span class="toggle-icon">[-]</span>Seeking / Scrolling</li>
                                    <li>
                                        <label for="invert-scroll-toggle">Invert Scroll Direction</label>
                                        <input type="checkbox" id="invert-scroll-toggle" class="toggle" checked>
                                    </li>
                                    <li>
                                        <label for="scroll-smoothness-slider">Scroll Smoothness</label>
                                        <input type="range" id="scroll-smoothness-slider" min="0" max="1" value="0.25" step="0.05">
                                    </li>
                                     <li>
                                        <label for="pause-on-scroll-toggle">Pause playback while seeking</label>
                                        <input type="checkbox" id="pause-on-scroll-toggle" class="toggle" checked>
                                    </li>
                                    <li class="mini-section-header" style="padding-top: 15px; margin-top: 10px;"><span class="toggle-icon">[-]</span>Debugging</li>
                                    <li>
                                        <label for="show-debug-toggle">Show Debug Button</label>
                                        <input type="checkbox" id="show-debug-toggle" class="toggle">
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="tab-content-game" class="tab-content">
                    <div id="game-settings" class="panel">
                        <h3 class="panel-header"><span class="toggle-icon">[-]</span>Game Settings</h3>
                        <div class="panel-content">
                            <div class="panel-content-inner">
                                <ul class="settings-list">
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Gameplay</li>
                                    <li>
                                        <label for="difficulty-select">Difficulty</label>
                                        <select id="difficulty-select">
                                            <option value="easy">Easy</option>
                                            <option value="normal" selected>Normal</option>
                                            <option value="hard">Hard</option>
                                            <option value="custom">Custom</option>
                                        </select>
                                    </li>
                                    <li><label for="autoplay-toggle">Enable Auto-Play</label><input type="checkbox" id="autoplay-toggle" class="toggle"></li>

                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Keyboard Rhythm Game</li>


                                    <!-- MODIFIED: Applied the 'full-width-control' class for the new layout -->

                                    <li class="full-width-control" style="padding-bottom: 0px;">
                                        <label for="kb-game-lanes-slider">Number of Lanes</label>
                                        <div class="control-container">
                                            <input type="range" id="kb-game-lanes-slider" min="4" max="10" value="4" step="1">
                                            <span id="kb-lanes-value-display">4</span>
                                        </div>
                                    </li>

                                    <!-- This item already has the correct class and structure -->

                                    <li class="full-width-control">
                                        <label for="kb-game-algorithm-select">Note Mapping Algorithm</label>
                                        <select id="kb-game-algorithm-select">
                                            <optgroup label="Standard">
                                                <option value="dynamic" selected>Dynamic Pitch Windowing</option>
                                                <option value="zoned">Zoned Pitch Mapping</option>
                                            </optgroup>
                                            <optgroup label="Playable & Ergonomic">
                                                <option value="alternating">Alternating Heuristic</option>
                                            </optgroup>
                                            <optgroup label="Experimental">
                                                <option value="velocity">Velocity Projection</option>
                                                <option value="density">Least-Loaded Fill</option>
                                                <option value="greedy">Greedy Fill</option>
                                                <option value="strict">Strict Pitch Projection</option>
                                            </optgroup>
                                        </select>
                                    </li>

                                    <li>
                                        <label for="kb-game-note-color-toggle">Color Keys On Press</label>
                                        <input type="checkbox" id="kb-game-note-color-toggle" class="toggle" checked>
                                    </li>



                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Countdown & Metronome</li>
                                    <li><label for="countdown-toggle">Enable Countdown</label><input type="checkbox" id="countdown-toggle" class="toggle" checked></li>
                                    <li><label for="metronome-volume-slider">Metronome Volume</label><input type="range" id="metronome-volume-slider" min="-40" max="0" value="-10" step="1"></li>
                                    <li><label for="countdown-tempo-slider">Default Tempo (BPM)</label><input type="range" id="countdown-tempo-slider" min="60" max="240" value="120" step="5"></li>

                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Calibration</li>
                                    <li><label for="global-offset-slider">Global Offset (ms)</label><input type="range" id="global-offset-slider" min="-200" max="200" value="0" step="1"></li>
                                    <li><button id="open-sync-btn" class="btn" style="width: 100%; margin-top: 5px;">Run Sync Calibration</button></li>
                                    
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Timing Windows</li>
                                    <li><label for="timing-window-slider">Overall Timing Window (%)</label><input type="range" id="timing-window-slider" min="50" max="200" value="100" step="5"></li>
                                    <li><label for="perfect-window-slider">Perfect Window (ms)</label><input type="range" id="perfect-window-slider" data-gametweak="perfect" min="10" max="100" value="50" step="1"></li>
                                    <li><label for="good-window-slider">Good Window (ms)</label><input type="range" id="good-window-slider" data-gametweak="good" min="50" max="200" value="100" step="5"></li>
                                    
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Scoring</li>
                                    <li><label for="base-score-slider">Base Score Multiplier</label><input type="range" id="base-score-slider" min="0.1" max="2.0" value="1.0" step="0.1"></li>
                                    <li><label for="combo-bonus-slider">Combo Bonus Multiplier</label><input type="range" id="combo-bonus-slider" data-gametweak="combo" min="0.0" max="2.0" value="1.0" step="0.1"></li>
                                    <li><label for="hold-score-slider">Hold Score Per Second</label><input type="range" id="hold-score-slider" min="0" max="100" value="20" step="5"></li>
                                    
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Accuracy</li>
                                    <li><label for="hold-accuracy-slider">Hold Accuracy Intensity</label><input type="range" id="hold-accuracy-slider" data-gametweak="accuracy" min="0.5" max="1.0" value="0.9" step="0.05"></li>
                                    <li><label for="overhold-window-slider">Over-hold Penalty Window (s)</label><input type="range" id="overhold-window-slider" min="0.05" max="0.5" value="0.15" step="0.01"></li>
                                    
                                    <li class="mini-section-header"><span class="toggle-icon">[-]</span>Velocity</li>
                                    <li><label for="velocity-scoring-toggle">Enable Velocity Scoring</label><input type="checkbox" id="velocity-scoring-toggle" class="toggle"></li>
                                    <li><label for="velocity-sensitivity-slider">Velocity Sensitivity</label><input type="range" id="velocity-sensitivity-slider" min="0.1" max="2.0" value="1.0" step="0.1"></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="tutorial-container">
                <div id="watermark" style="text-align: center; color: var(--text-light-color); font-size: 0.8em; user-select: none;">
                    &copy; NASHqp 2026
                </div>
                <div id="tutorial-icon" title="Show Tutorial">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
                </div>
            </div>
        </aside>
    </div>

    <div id="game-mode-choice-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Select Game Mode</h2>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <button id="start-midi-game-btn" class="btn game-mode-option-btn">
                    <svg viewBox="0 0 24 24"><path d="M19,5V19H5V5H19M21,3H3V21H21V3M7,7V13H9V7H7M11,7V13H13V7H11M15,7V13H17V7H15Z" /></svg>
                    <div>
                        <strong>MIDI Input Mode</strong>
                        <p style="font-size: 0.8em; margin: 4px 0 0; color: #ffffff;">Play along using a connected MIDI keyboard.</p>
                    </div>
                </button>
                <button id="start-kb-game-btn" class="btn game-mode-option-btn">
                    <svg viewBox="0 0 24 24"><path d="M20,5H4C2.89,5 2,5.89 2,7V17C2,18.11 2.89,19 4,19H20C21.11,19 22,18.11 22,17V7C22,5.89 21.11,5 20,5M20,17H4V7H20V17M13,9H15V11H13V9M13,13H15V15H13V13M9,9H11V11H9V9M9,13H11V15H9V13M5,9H7V11H5V9M5,13H7V15H5V13M17,9H19V11H17V9M17,13H19V15H17V13Z" /></svg>
                    <div>
                        <strong>Keyboard Rhythm Game</strong>
                        <p style="font-size: 0.8em; margin: 4px 0 0; color: #ffffff;">Play using your computer keyboard in scrolling lanes.</p>
                    </div>
                </button>
            </div>
        </div>
    </div>


    <div id="channel-settings-modal-overlay" class="modal-overlay">
        <div id="channel-settings-modal" class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Channel Settings</h2>
                <button id="modal-close-btn" class="modal-close">&times;</button>
            </div>
            <div id="modal-body" class="modal-body">
            </div>
        </div>
    </div>
    
    <div id="results-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Results</h2>
            </div>
            <div class="modal-body" id="results-body">
                <div class="result-item"><span>Score</span><span id="result-score">0</span></div>
                <div class="result-item"><span>Accuracy</span><span id="result-accuracy">0%</span></div>
                <div class="result-item"><span>Max Combo</span><span id="result-max-combo">0</span></div>
                <hr>
                <div class="result-item"><span>Perfect</span><span id="result-perfect">0</span></div>
                <div class="result-item"><span>Good</span><span id="result-good">0</span></div>
                <div class="result-item"><span>Miss</span><span id="result-miss">0</span></div>
                <div class="result-item"><span>Extra Hits</span><span id="result-extra">0</span></div>
                <hr>
                <div class="result-item"><span>Total Notes</span><span id="result-total-notes">0</span></div>
            </div>
            <div class="modal-footer">
                <button id="restart-game-btn" class="btn">Restart</button>
                <button id="continue-btn" class="btn">Continue</button>
            </div>
        </div>
    </div>

    <div id="sync-modal-overlay" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2>Sync Calibration</h2>
                <button id="reset-sync-btn" class="btn btn-secondary" style="margin-top: 0;">Reset</button>
            </div>
            <div class="modal-body" id="sync-body">
                <p id="sync-instructions">Press 'Begin Test' then tap any key on your MIDI device in time with the sound and visual pulse.</p>
                <div id="sync-visualizer">
                    <div id="sync-bar"></div>
                    <div id="sync-marker"></div>
                </div>
                <div id="sync-results">
                    <div id="sync-results-summary">
                         <p>Average Offset: <strong id="sync-avg-offset">-- ms</strong></p>
                         <p>Stability (Jitter): <strong id="sync-stability">-- ms</strong></p>
                    </div>
                    <div id="sync-plot-container">
                        <svg id="sync-plot" viewBox="0 0 100 50"></svg>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="justify-content: space-between; align-items: center;">
                <button id="cancel-sync-btn" class="btn btn-secondary">Cancel</button>
                <div>
                    <button id="sync-start-btn" class="btn btn-go" style="margin-top: 0;">Begin Test</button>
                    <button id="apply-sync-btn" class="btn" disabled style="margin-top: 0; display: none;">Apply & Close</button>
                </div>
            </div>
        </div>
    </div>


    <!-- NEW: Tutorial Overlay -->
    <div id="tutorial-overlay">
        <div class="tutorial-caption-box">
            <div class="tutorial-caption-header">
                <h4 id="tutorial-title">Tutorial Title</h4>
                <button id="tutorial-close-btn" class="tutorial-caption-close">&times;</button>
            </div>
            <div class="tutorial-caption-body">
                <p id="tutorial-text">This is the explanation for the highlighted feature.</p>
            </div>
            <div class="tutorial-caption-footer">
                <span id="tutorial-step-counter">1 / X</span>
                <div class="tutorial-nav-btns">
                    <button id="tutorial-prev-btn" class="btn btn-secondary">Prev</button>
                    <button id="tutorial-next-btn" class="btn">Next</button>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Original DOM Element references
            const pianoContainer = document.getElementById('piano-container');
            const fileInput = document.getElementById('midi-file-input');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const seekBar = document.getElementById('seek-bar');
            const volumeSlider = document.getElementById('volume-slider');
            const timeDisplay = document.getElementById('time-display');
            const notesContainer = document.getElementById('notes-container');
            const pulseContainer = document.getElementById('pulse-container');
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingFxContainer = document.getElementById('loading-fx-container');
            const dropZone = document.querySelector('.drop-zone');
            const debugToggle = document.getElementById('debug-toggle');
            const debugStats = document.getElementById('debug-stats');
            const modalOverlay = document.getElementById('channel-settings-modal-overlay');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const visualizerWrapper = document.getElementById('visualizer-wrapper');
            
            // Game Mode DOM Elements
            const gameModeBtn = document.getElementById('game-mode-btn');
            const accompanimentVolumeControl = document.getElementById('accompaniment-volume-control');
            const accompanimentVolumeSlider = document.getElementById('accompaniment-volume-slider');
            const gameHud = document.getElementById('game-hud');
            const scoreDisplay = document.getElementById('score-display');
            const comboDisplay = document.getElementById('combo-display');
            const judgementText = document.getElementById('judgement-text');
            const resultsOverlay = document.getElementById('results-overlay');
            const continueBtn = document.getElementById('continue-btn');
            const restartGameBtn = document.getElementById('restart-game-btn');
            const appContainer = document.getElementById('app-container');
            const countdownOverlay = document.getElementById('countdown-overlay');
            const countdownText = document.getElementById('countdown-text');
            const gameModeChoiceModal = document.getElementById('game-mode-choice-modal');

            // --- NEW: Keyboard Rhythm Game DOM Elements ---
            const keyboardGameContainer = document.getElementById('keyboard-game-container');
            const kbGameLanesContainer = document.getElementById('kb-game-lanes-container');
            let kbGameNotesContainer = document.getElementById('kb-game-notes-container'); // Use let to allow re-assignment
            const kbGameHitZone = document.getElementById('kb-game-hit-zone');

            // --- MIDI Packs DOM Elements ---
            const midiPacksInput = document.getElementById('midi-packs-input');
            const midiPacksList = document.getElementById('midi-packs-list');
            
            // --- Sync Calibration DOM Elements ---
            const syncModal = document.getElementById('sync-modal-overlay');
            const openSyncBtn = document.getElementById('open-sync-btn');
            const resetSyncBtn = document.getElementById('reset-sync-btn');
            const cancelSyncBtn = document.getElementById('cancel-sync-btn');
            const applySyncBtn = document.getElementById('apply-sync-btn');
            const syncStartBtn = document.getElementById('sync-start-btn');
            const syncMarker = document.getElementById('sync-marker');
            const syncBar = document.getElementById('sync-bar');
            const syncAvgOffset = document.getElementById('sync-avg-offset');
            const syncStability = document.getElementById('sync-stability');
            const syncInstructions = document.getElementById('sync-instructions');
            const syncPlot = document.getElementById('sync-plot');

            // --- NEW: Tutorial DOM Elements ---
            const tutorialIcon = document.getElementById('tutorial-icon');
            const tutorialOverlay = document.getElementById('tutorial-overlay');
            const tutorialCaptionBox = tutorialOverlay.querySelector('.tutorial-caption-box');
            const tutorialTitle = document.getElementById('tutorial-title');
            const tutorialText = document.getElementById('tutorial-text');
            const tutorialStepCounter = document.getElementById('tutorial-step-counter');
            const tutorialCloseBtn = document.getElementById('tutorial-close-btn');
            const tutorialPrevBtn = document.getElementById('tutorial-prev-btn');
            const tutorialNextBtn = document.getElementById('tutorial-next-btn');


            // --- State Variables ---
            let midiData = null, pianoSampler = null, drumSampler = null, audioParts = {}, popSynth = null, panner = null;
            let playerPianoSampler = null, calMetronome = null;
            // MODIFIED: Added playerGain for separate volume control
            let accompanimentGain = null, playerGain = null;
            let allNotes = [], enabledChannels = new Set();
            let channelInstruments = {};
            let channelOrder = [];
            let isPlaying = false, animationFrameId = null;
            let activeVisuals = new Set(), whiteKeyElements = {}, blackKeyElements = {};
            let liveMidiInput = null;
            let livePulseElements = new Map(); // For tracking live key pulses
            let clickedPianoKeys = new Set(); // NEW: Tracks mouse-clicked piano keys
            let midiToLaneMap = new Map(); // <-- ADD THIS LINE
            let currentMidiLoadId = 0;
            let preRollDuration = 0;
            let triggeredPulseNoteIds = new Set();
            let midiPacksData = {};
            let customPackCounter = 1;
            
            // --- Settings Variables ---
            let isPulseEnabled = true;
            let useNoteColorForPulse = false;
            let customPulseColor = '#ffffff';
            let pulseOpacity = 1.0;
            let noteFallSpeed = 550;
            let pulseDuration = 1.2;
            let isLowLagModeEnabled = true;
            let renderedNoteIds = new Set();
            let isSustainOn = false;
            let sustainedNotes = new Set();
            let lastFrameTime = 0, fps = 0;
            let showLoadingRibbon = false;
            let showLoadingBlur = true;
            let pauseOnScroll = true;
            let isPreRollEnabled = false;
            let isDividedPulseEnabled = false;
            // NEW: Loading animation settings
            let isNoteRevealAnimationEnabled = true;
            let noteRevealDuration = 2500;

            // --- Visual Aid Settings ---
            let isGuidanceModeEnabled = false;
            let guidanceModeStyle = 'glow';
            let isNoteLabelModeEnabled = false;
            let noteLabelOrientation = 'horizontal';
            let noteLabelPosition = 'middle';
            let noteLabelShowOctave = true;
            let noteLabelUseAutomaticColor = true;
            let guidedKeys = new Set();
            // NEW: Note outline settings
            let isNoteOutlineEnabled = false;
            let noteOutlineStyle = 'inward';
            let noteOutlineUseAutomaticColor = true;


            // --- Smooth Scroll Variables ---
            let invertScroll = true;
            let scrollLerpFactor = 0.1; 
            let scrollTargetTime = 0;
            let currentScrollTime = 0;
            let scrollAnimationId = null;

            // --- Game Mode State ---
            let activeGameMode = 'none'; // 'none', 'midi', 'keyboard'
            let gameSessionActive = false;
            let gameEndingState = 0;
            // accompanimentGain is already declared above
            let playerHeldNotes = new Map();
            let lastHeldNoteStatus = "N/A";
            const initialGameStats = { score: 0, combo: 0, maxCombo: 0, perfect: 0, good: 0, miss: 0, extra: 0 };
            let gameStats = {};
            let isAutoPlay = false;
            let autoPlayPart = null;

            // --- NEW: Keyboard Game State ---
            let kbGameNumLanes = 4;
            let kbGameKeybinds = ['d', 'f', 'j', 'k'];
            let kbGameLaneNotes = []; // Processed notes for keyboard mode
            let kbGamePlayerHeldKeys = new Map(); // laneIndex -> { gameNote, startTime, ... }
            let kbGameRenderedNoteIds = new Set();
            let kbGameUseNoteColor = true;
            let kbGameAlgorithm = 'zoned'; // NEW: State for the selected algorithm

            // --- Sync Calibration State ---
            let isSyncing = false;
            let syncTaps = [];
            let syncLoop = null;
            let wasPlayingBeforeSync = false;
            let nextBeatTime = 0;
            const SYNC_TOTAL_TAPS = 12;
            const SYNC_BPM = 100;
            const SYNC_INTERVAL = 60 / SYNC_BPM;

            // --- Game Settings Variables ---
            let globalOffset = 0;
            let timingWindowMultiplier = 1.0;
            let basePerfectWindow = 0.050;
            let baseGoodWindow = 0.100;
            let perfectWindow = 0.05;
            let goodWindow = 0.10;
            let missWindow = 0.15;
            let baseScore = 1.0;
            let comboBonus = 1.0;
            let holdScorePerSecond = 20;
            let holdAccuracyIntensity = 0.9;
            let overholdPenaltyWindow = 0.15;
            let isVelocityScoringEnabled = false;
            let velocitySensitivity = 1.0;
            let isCountdownEnabled = true;
            let countdownDefaultTempo = 120;


            // --- NEW: Tutorial State ---
            let tutorialActive = false;
            let currentTutorialStep = 0;
            const tutorialSteps = [
                {
                    element: '.drop-zone .panel-content-inner',
                    title: '1. Load Your MIDI',
                    text: 'Welcome! Start by dragging a MIDI file here, or use the button to select one from your computer. This is the first step to seeing the magic.'
                },
                {
                    element: '#midi-packs-panel .btn',
                    title: '2. Load MIDI Packs',
                    text: 'You can also load an entire folder of organized MIDI files. Click here and select a folder containing subfolders for each "pack".'
                },
                {
                    element: '.playback-controls',
                    title: '3. Playback Controls',
                    text: 'After loading a file, use these buttons to control the visualization. The main button is Play/Pause (or Spacebar).'
                },
                {
                    element: '#seek-bar',
                    title: '4. Navigate Your Song',
                    text: 'Click and drag this seek bar to jump to any part of the song instantly. You can also use your mouse wheel over the visualizer.'
                },
                {
                    element: '#channel-mixer',
                    title: '5. Mix & Match Channels',
                    text: 'A MIDI file has multiple instrument channels. Here you can mute channels, change their colors, or drag to reorder their visual layers.'
                },
                {
                    element: '[data-tab="appearance"]',
                    title: '6. Customize Appearance',
                    text: 'This is where you can personalize the look and feel. Click the Appearance tab to explore themes, colors, and visual effects.'
                },
                {
                    element: '#dark-mode-toggle',
                    title: '7. Dark & Light Themes',
                    text: 'Switch between light and dark modes instantly. All color settings can be customized for both themes independently.',
                    tab: 'appearance' // Specify which tab this is in
                },
                {
                    element: '#note-label-toggle',
                    title: '8. Style Your Notes',
                    text: 'Make the notes easier to read! In this section, you can add note name labels, enable outlines, and fine-tune their appearance.',
                    tab: 'appearance'
                },
                {
                    element: '[data-tab="performance"]',
                    title: '9. Fine-Tune Performance',
                    text: 'The Performance tab lets you adjust animation speeds and enable modes to reduce lag on slower computers.'
                },
                {
                    element: '#note-speed-slider',
                    title: '10. Adjust Note Speed',
                    text: 'Control how fast the notes fall. A higher value means notes are more spread out and fall faster. Find the speed that works best for you.',
                    tab: 'performance'
                },
                {
                    element: '#game-mode-btn',
                    title: '11. Play the Rhythm Game',
                    text: 'Ready for a challenge? Click here to open the Game Mode selector. You can play along with your MIDI keyboard or your computer keyboard.'
                },
                {
                    element: '#open-sync-btn',
                    title: '12. Calibrate Your Timing',
                    text: 'Before playing a game, run this sync tool. It measures and corrects for audio or input delay, ensuring your hits are registered accurately.',
                    tab: 'game'
                }
            ];


            // --- Keybinds ---
            let keybinds = {
                togglePlay: ' ',
                resetPlayback: 'r',
                gameExit: 'Escape'
            };
            let isListeningForKey = false;

            // --- Constants ---
            const INITIAL_HUES = [0, 20, 40, 60, 80, 120, 150, 180, 210, 240, 270, 300, 320, 330, 340, 350];
            let channelHues = {};
            const playIcon = `<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`;
            const pauseIcon = `<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;
            const GM_DRUM_MAP = { 35: "Acoustic Bass Drum", 36: "Bass Drum 1", 37: "Side Stick", 38: "Acoustic Snare", 39: "Hand Clap", 40: "Electric Snare", 41: "Low Floor Tom", 42: "Closed Hi-Hat", 43: "High Floor Tom", 44: "Pedal Hi-Hat", 45: "Low Tom", 46: "Open Hi-Hat", 47: "Low-Mid Tom", 48: "Hi-Mid Tom", 49: "Crash Cymbal 1", 50: "High Tom", 51: "Ride Cymbal 1", 52: "Chinese Cymbal", 53: "Ride Bell", 54: "Tambourine", 55: "Splash Cymbal", 56: "Cowbell", 57: "Crash Cymbal 2", 58: "Vibraslap", 59: "Ride Cymbal 2", 60: "Hi Bongo", 61: "Low Bongo", 62: "Mute Hi Conga", 63: "Open Hi Conga", 64: "Low Conga", 65: "High Timbale", 66: "Low Timbale", 67: "High Agogo", 68: "Low Agogo", 69: "Cabasa", 70: "Maracas", 71: "Short Whistle", 72: "Long Whistle", 73: "Short Guiro", 74: "Long Guiro", 75: "Claves", 76: "Hi Wood Block", 77: "Low Wood Block", 78: "Mute Cuica", 79: "Open Cuica", 80: "Mute Triangle", 81: "Open Triangle" };
            const difficultyPresets = {
                easy:   { perfect: 80, good: 160, combo: 0.5, accuracy: 1.0, timingWindow: 125 },
                normal: { perfect: 50, good: 100, combo: 1.0, accuracy: 0.9, timingWindow: 100 },
                hard:   { perfect: 30, good: 70,  combo: 1.2, accuracy: 0.8, timingWindow: 80 }
            };
            const themeConfig = {
                light: {
                    '--bg-color': '#f4f7fa', '--app-bg': '#ffffff', '--piano-bg': '#eef1f5',
                    '--text-color': '#3d4a5c', '--accent-color': '#5e81f4',
                    '--hit-line-color': '#ff7b7b', '--piano-outline-color': '#d1d5db',
                    '--note-label-fill-color': '#ffffff', '--note-label-outline-color': '#000000',
                    '--guidance-color': '#5e81f4', '--note-outline-color': '#000000'
                },
                dark: {
                    '--bg-color': '#1a1b26', '--app-bg': '#24283b', '--piano-bg': '#1e2029',
                    '--text-color': '#c0caf5', '--accent-color': '#7aa2f7',
                    '--hit-line-color': '#f7768e', '--piano-outline-color': '#3b4261',
                    '--note-label-fill-color': '#000000', '--note-label-outline-color': '#ffffff',
                    '--guidance-color': '#7aa2f7', '--note-outline-color': '#ffffff'
                }
            };


            function isBlackKey(midi) { const note = midi % 12; return [1, 3, 6, 8, 10].includes(note); }
            
            function createPiano() {
                pianoContainer.innerHTML = '';
                whiteKeyElements = {}; blackKeyElements = {};
                const whiteKeyCount = Array.from({ length: 108 - 21 + 1 }, (_, i) => i + 21).filter(m => !isBlackKey(m)).length;
                let whiteKeyIndex = 0;
                for (let i = 21; i <= 108; i++) {
                    const key = document.createElement('div');
                    key.id = `key-${i}`;
                    key.dataset.midi = i; // Store midi number in dataset
                    key.classList.add('piano-key');
                    if (isBlackKey(i)) {
                        key.classList.add('black-key');
                        key.style.left = `${(whiteKeyIndex - 0.3) * (100 / whiteKeyCount)}%`;
                        blackKeyElements[i] = key;
                    } else {
                        key.classList.add('white-key');
                        whiteKeyElements[i] = key;
                        whiteKeyIndex++;
                    }

                    // --- NEW: Add event listeners for mouse/touch interaction ---
                    key.addEventListener('pointerdown', (e) => {
                        e.preventDefault(); // Prevent text selection/dragging
                        const midi = parseInt(e.target.dataset.midi);
                        if (!clickedPianoKeys.has(midi)) {
                            handlePianoKeyPress(midi);
                            clickedPianoKeys.add(midi);
                        }
                    });

                    key.addEventListener('pointerup', (e) => {
                        e.preventDefault();
                        const midi = parseInt(e.target.dataset.midi);
                        if (clickedPianoKeys.has(midi)) {
                            handlePianoKeyRelease(midi);
                            clickedPianoKeys.delete(midi);
                        }
                    });

                    key.addEventListener('pointerleave', (e) => {
                        e.preventDefault();
                        const midi = parseInt(e.target.dataset.midi);
                        if (clickedPianoKeys.has(midi)) {
                            handlePianoKeyRelease(midi);
                            clickedPianoKeys.delete(midi);
                        }
                    });

                    pianoContainer.appendChild(key);
                }
            }

            // --- NEW: Function to handle piano key press from mouse ---
            async function handlePianoKeyPress(midi) {
                if (Tone.context.state !== 'running') await Tone.start();
                if (!playerPianoSampler) return;
                
                const velocity = 0.75; // Default velocity for clicks
                const noteName = new Tone.Frequency(midi, "midi").toNote();

                playerPianoSampler.triggerAttack(noteName, Tone.now(), velocity);
                
                // Trigger column pulse as before
                triggerColumnPulse({ midi: midi, velocity: velocity, channel: 10, duration: 0.5 });

                // Manually handle the key pulse visual to control its release
                if (livePulseElements.has(midi)) {
                    livePulseElements.get(midi).remove();
                }
                const keyEl = document.getElementById(`key-${midi}`);
                if (keyEl) {
                    const pulseEl = document.createElement('div');
                    pulseEl.className = 'key-pulse-visual';
                    pulseEl.style.backgroundColor = getColorForNote({ midi: midi, velocity, channel: 10 });
                    pulseEl.style.animationDuration = '10s'; // Long duration, will be cut short on release
                    pulseEl.addEventListener('animationend', () => pulseEl.remove(), { once: true });
                    keyEl.appendChild(pulseEl);
                    livePulseElements.set(midi, pulseEl);
                }
                
                // If in game mode, check for hit
                if (activeGameMode === 'midi' && isPlaying && !isAutoPlay) {
                    checkPlayerHit(midi, velocity);
                }
            }

            // --- NEW: Function to handle piano key release from mouse ---
            function handlePianoKeyRelease(midi) {
                if (!playerPianoSampler) return;

                const noteName = new Tone.Frequency(midi, "midi").toNote();
                playerPianoSampler.triggerRelease(noteName, Tone.now());

                // Handle the visual release of the key pulse
                if (livePulseElements.has(midi)) {
                    const pulseEl = livePulseElements.get(midi);
                    pulseEl.style.animationDuration = '0.3s'; // Triggers fade-out and removal
                    livePulseElements.delete(midi);
                }

                // If in game mode, handle release
                if (activeGameMode === 'midi' && isPlaying && !isAutoPlay) {
                    handleNoteRelease(midi);
                }
            }

            function createGridLines() {
                const gridContainer = document.getElementById('grid-container');
                if (!gridContainer || !pianoContainer) return;
                gridContainer.innerHTML = '';
                const fragment = document.createDocumentFragment();
                const pianoWidth = pianoContainer.offsetWidth;
                if (pianoWidth === 0) return;

                Object.values(blackKeyElements).forEach(keyEl => {
                    const shade = document.createElement('div');
                    shade.className = 'grid-black-key-area';
                    shade.style.left = `${(keyEl.offsetLeft / pianoWidth) * 100}%`;
                    shade.style.width = `${(keyEl.offsetWidth / pianoWidth) * 100}%`;
                    fragment.appendChild(shade);
                });

                Object.values(whiteKeyElements).forEach(keyEl => {
                    const line = document.createElement('div');
                    line.className = 'grid-line';
                    line.style.left = `${(keyEl.offsetLeft / pianoWidth) * 100}%`;
                    fragment.appendChild(line);
                });

                const finalLine = document.createElement('div');
                finalLine.className = 'grid-line';
                finalLine.style.right = '0px';
                fragment.appendChild(finalLine);

                gridContainer.appendChild(fragment);
            }
            
            function getColorForNote(note) {
                const hue = channelHues[note.channel] || 0;
                const lightness = 95 - (note.velocity * 50);
                return `hsl(${hue}, 90%, ${lightness}%)`;
            }

            function getContrastingColors(hslColor) {
                try {
                    const l_string = hslColor.match(/,\s*([\d.]+)%\)/)[1];
                    const l = parseFloat(l_string);
                    if (l > 55) {
                        return { fill: '#000000', outline: 'rgba(255, 255, 255, 0.6)' };
                    } else {
                        return { fill: '#FFFFFF', outline: 'rgba(0, 0, 0, 0.6)' };
                    }
                } catch (e) {
                    return { fill: '#FFFFFF', outline: 'rgba(0, 0, 0, 0.6)' };
                }
            }

            // NEW: Helper to darken HSL colors for automatic outlines
            function darkenHsl(hslColor, amount) {
                try {
                    const match = hslColor.match(/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/);
                    if (!match) return hslColor;
                    const h = match[1];
                    const s = match[2];
                    let l = parseFloat(match[3]);
                    l = Math.max(0, l - amount);
                    return `hsl(${h}, ${s}%, ${l}%)`;
                } catch (e) {
                    return hslColor;
                }
            }

            function colorToRgba(colorStr) {
                const ctx = document.createElement('canvas').getContext('2d');
                if (!ctx) return { r:0, g:0, b:0, a:1};
                ctx.fillStyle = colorStr;
                const hex = ctx.fillStyle; 
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return {r, g, b};
            }

            async function initializeInstruments() {
                // MODIFIED: Separated gain nodes for accompaniment and live player input
                accompanimentGain = new Tone.Gain(accompanimentVolumeSlider.value).toDestination();
                playerGain = new Tone.Gain().toDestination(); // Volume set by slider later
                
                const samplerSettings = {
                    urls: { A1: "A1.mp3", A2: "A2.mp3", A3: "A3.mp3", A4: "A4.mp3", A5: "A5.mp3", A6: "A6.mp3", C2: "C2.mp3", C3: "C3.mp3", C4: "C4.mp3", C5: "C5.mp3", C6: "C6.mp3", C7: "C7.mp3", },
                    release: 1, baseUrl: "https://tonejs.github.io/audio/salamander/"
                };
                
                pianoSampler = new Tone.Sampler(samplerSettings).connect(accompanimentGain);
                // MODIFIED: Connect player sampler to its dedicated gain node
                playerPianoSampler = new Tone.Sampler(samplerSettings).connect(playerGain);
                
                drumSampler = new Tone.Sampler({
                    urls: { "C3": "kick.mp3", "C#3": "snare.mp3", "D3": "hh.mp3", "D#3": "hho.mp3", "E3": "clap.mp3" },
                    release: 1, baseUrl: "https://tonejs.github.io/audio/drum-samples/CR78/"
                }).connect(accompanimentGain);
                
                calMetronome = new Tone.MembraneSynth({
                    pitchDecay: 0.008,
                    octaves: 4,
                    envelope: { attack: 0.001, decay: 0.3, sustain: 0 }
                }).toDestination();
                calMetronome.volume.value = -10;

                pianoSampler.volume.value = 0;
                drumSampler.volume.value = 0;

                // REVAMPED: This slider now controls the playerGain with a linear value
                playerGain.gain.value = parseFloat(volumeSlider.value);
                
                await Tone.loaded();
            }

            function initializePopSynth() {
                panner = new Tone.Panner(0).toDestination();
                popSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.01, octaves: 6,
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.001, decay: 0.04, sustain: 0.01, release: 0.01, }
                }).connect(panner);
                popSynth.volume.value = -22;
            }

            function initializeSettings() {
                document.querySelectorAll('#theme-editor input[type="color"], #visual-aids-panel input[type="color"]').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const isDark = document.getElementById('dark-mode-toggle').checked;
                        const variable = isDark ? (e.target.dataset.darkVariable || e.target.dataset.variable) : e.target.dataset.variable;
                        document.documentElement.style.setProperty(variable, e.target.value)
                    });
                });
                const darkModeToggle = document.getElementById('dark-mode-toggle');
                darkModeToggle.addEventListener('change', (e) => {
                    document.body.classList.toggle('dark-mode', e.target.checked);
                    applyTheme(e.target.checked);
                });
                
                document.getElementById('hit-line-toggle').addEventListener('change', (e) => document.body.classList.toggle('hit-line-hidden', !e.target.checked));
                document.getElementById('piano-outline-toggle').addEventListener('change', (e) => document.body.classList.toggle('piano-outline-hidden', !e.target.checked));
                document.getElementById('pulse-toggle').addEventListener('change', (e) => isPulseEnabled = e.target.checked);
                document.getElementById('pulse-color-toggle').addEventListener('change', (e) => useNoteColorForPulse = e.target.checked);
                document.getElementById('pulse-color-input').addEventListener('input', (e) => customPulseColor = e.target.value);
                document.getElementById('loading-ribbon-toggle').addEventListener('change', (e) => showLoadingRibbon = e.target.checked);
                document.getElementById('loading-blur-toggle').addEventListener('change', (e) => showLoadingBlur = e.target.checked);
                document.getElementById('loading-ribbon-thickness').addEventListener('input', (e) => document.documentElement.style.setProperty('--loading-ribbon-thickness', `${e.target.value}px`));
                document.getElementById('loading-blur-amount').addEventListener('input', (e) => document.documentElement.style.setProperty('--loading-blur-amount', `${e.target.value}px`));
                document.getElementById('divided-pulse-toggle').addEventListener('change', e => isDividedPulseEnabled = e.target.checked);

                // --- NEW: Loading Animation Settings Listeners ---
                document.getElementById('note-reveal-anim-toggle').addEventListener('change', e => isNoteRevealAnimationEnabled = e.target.checked);
                document.getElementById('note-reveal-duration-slider').addEventListener('input', e => noteRevealDuration = parseInt(e.target.value));
                document.getElementById('note-reveal-opacity-slider').addEventListener('input', e => {
                    const opacity = parseFloat(e.target.value) / 100;
                    document.documentElement.style.setProperty('--dim-overlay-opacity', opacity);
                });

                document.getElementById('guidance-mode-toggle').addEventListener('change', e => isGuidanceModeEnabled = e.target.checked);
                document.getElementById('guidance-style-select').addEventListener('change', e => guidanceModeStyle = e.target.value);
                document.getElementById('guidance-opacity-slider').addEventListener('input', e => {
                     document.documentElement.style.setProperty('--guidance-opacity', parseFloat(e.target.value) / 100);
                });
                document.getElementById('pulse-opacity-slider').addEventListener('input', e => {
                    pulseOpacity = parseFloat(e.target.value) / 100;
                });

                document.getElementById('grid-mode-toggle').addEventListener('change', e => document.body.classList.toggle('grid-mode-active', e.target.checked));
                document.getElementById('grid-shading-slider').addEventListener('input', e => {
                    const opacity = parseFloat(e.target.value) / 100;
                    document.documentElement.style.setProperty('--grid-black-key-opacity', opacity);
                });
                
                // --- REFACTORED: Note Outline Settings ---
                const noteOutlineToggle = document.getElementById('note-outline-toggle');
                const noteOutlineStyleSelect = document.getElementById('note-outline-style-select');
                const noteOutlineWidthSlider = document.getElementById('note-outline-width-slider');
                const noteOutlineAutoColorToggle = document.getElementById('note-outline-auto-color-toggle');
                const noteOutlineColorInput = document.getElementById('note-outline-color-input');

                function setOutlineColorInputState(isAuto) {
                    noteOutlineColorInput.parentElement.style.display = isAuto ? 'none' : 'flex';
                }

                function updateNoteOutlines() {
                    isNoteOutlineEnabled = noteOutlineToggle.checked;
                    noteOutlineStyle = noteOutlineStyleSelect.value;
                    noteOutlineUseAutomaticColor = noteOutlineAutoColorToggle.checked;
                    setOutlineColorInputState(noteOutlineUseAutomaticColor);
                    document.documentElement.style.setProperty('--note-outline-width', `${noteOutlineWidthSlider.value}px`);

                    document.querySelectorAll('.note-visual').forEach(el => {
                        const noteId = parseInt(el.id.replace('note-visual-', ''));
                        if (!isNaN(noteId) && allNotes && allNotes[noteId]) {
                           applyNoteOutlineStyle(el, allNotes[noteId]);
                        }
                    });
                }
                noteOutlineToggle.addEventListener('change', updateNoteOutlines);
                noteOutlineStyleSelect.addEventListener('change', updateNoteOutlines);
                noteOutlineWidthSlider.addEventListener('input', updateNoteOutlines);
                noteOutlineAutoColorToggle.addEventListener('change', updateNoteOutlines);
                setOutlineColorInputState(noteOutlineAutoColorToggle.checked);


                const noteLabelToggle = document.getElementById('note-label-toggle');
                const noteLabelOrientationSelect = document.getElementById('note-label-orientation-select');
                const noteLabelPositionSelect = document.getElementById('note-label-position-select');
                const noteLabelOctaveToggle = document.getElementById('note-label-octave-toggle');
                const noteLabelCustomColorToggle = document.getElementById('note-label-custom-color-toggle');
                const noteLabelFillColorInput = document.getElementById('note-label-fill-color');
                const noteLabelOutlineColorInput = document.getElementById('note-label-outline-color');

                function setLabelColorInputsState(enabled) {
                    noteLabelFillColorInput.disabled = enabled;
                    noteLabelOutlineColorInput.disabled = enabled;
                }

                function updateNoteLabels() {
                    isNoteLabelModeEnabled = noteLabelToggle.checked;
                    noteLabelOrientation = noteLabelOrientationSelect.value;
                    noteLabelPosition = noteLabelPositionSelect.value;
                    noteLabelShowOctave = noteLabelOctaveToggle.checked;
                    noteLabelUseAutomaticColor = noteLabelCustomColorToggle.checked;
                    setLabelColorInputsState(noteLabelUseAutomaticColor);
                    
                    if (midiData) {
                        notesContainer.innerHTML = '';
                        renderedNoteIds.clear();
                        if (!isLowLagModeEnabled) {
                            loadingOverlay.classList.add('visible');
                            setupVisualizerAsync(currentMidiLoadId).then(() => {
                                document.querySelectorAll('.note-visual').forEach(el => el.classList.add('visible'));
                                loadingOverlay.classList.remove('visible');
                            });
                        } else {
                            updateVisuals(Tone.Transport.seconds);
                        }
                    }
                }

                noteLabelToggle.addEventListener('change', updateNoteLabels);
                noteLabelOrientationSelect.addEventListener('change', updateNoteLabels);
                noteLabelPositionSelect.addEventListener('change', updateNoteLabels);
                noteLabelOctaveToggle.addEventListener('change', updateNoteLabels);
                noteLabelCustomColorToggle.addEventListener('change', updateNoteLabels);

                setLabelColorInputsState(noteLabelCustomColorToggle.checked);
                applyTheme(darkModeToggle.checked);

                document.getElementById('note-speed-slider').addEventListener('input', (e) => {
                    noteFallSpeed = parseFloat(e.target.value);
                    if (midiData && !isLowLagModeEnabled) {
                        setupVisualizerAsync(currentMidiLoadId).then(() => {
                            document.querySelectorAll('.note-visual').forEach(el => el.classList.add('visible'));
                        });
                    } else if (midiData) {
                        seekTo(Tone.Transport.seconds);
                    }
                });
                document.getElementById('pulse-duration-slider').addEventListener('input', (e) => {
                    pulseDuration = parseFloat(e.target.value);
                    document.documentElement.style.setProperty('--pulse-duration', `${pulseDuration}s`);
                });
                document.getElementById('less-lag-toggle').addEventListener('change', (e) => {
                    isLowLagModeEnabled = e.target.checked;
                    if (midiData) {
                        notesContainer.innerHTML = ''; 
                        renderedNoteIds.clear();
                        if (!isLowLagModeEnabled) { 
                            loadingOverlay.classList.add('visible');
                            requestAnimationFrame(() => { 
                                setupVisualizerAsync(currentMidiLoadId).then(() => {
                                    document.querySelectorAll('.note-visual').forEach(el => el.classList.add('visible'));
                                    loadingOverlay.classList.remove('visible');
                                });
                            });
                        } else {
                            updateVisuals(Tone.Transport.seconds);
                        }
                    }
                    updateDebugStats();
                });
                document.getElementById('preroll-toggle').addEventListener('change', async e => {
                    isPreRollEnabled = e.target.checked;
                    if (midiData && activeGameMode === 'none') {
                        if (isPlaying) await togglePlayPause();
                        const tempo = midiData.header.tempos[0]?.bpm || countdownDefaultTempo;
                        preRollDuration = isPreRollEnabled ? (60 / tempo) * 4 : 0;
                        seekBar.max = midiData.duration + preRollDuration;
                        updateFilteredPlayback();
                        seekTo(0);
                    }
                });
                isPreRollEnabled = document.getElementById('preroll-toggle').checked;

                document.getElementById('invert-scroll-toggle').addEventListener('change', (e) => invertScroll = e.target.checked);
                document.getElementById('scroll-smoothness-slider').addEventListener('input', (e) => { scrollLerpFactor = 0.2 - (parseFloat(e.target.value) * 0.19); });
                document.getElementById('pause-on-scroll-toggle').addEventListener('change', e => pauseOnScroll = e.target.checked);
                scrollLerpFactor = 0.2 - (parseFloat(document.getElementById('scroll-smoothness-slider').value) * 0.19);
                invertScroll = document.getElementById('invert-scroll-toggle').checked;
                
                initializeGameSettings();

                const showDebugToggle = document.getElementById('show-debug-toggle');
                showDebugToggle.addEventListener('change', (e) => {
                    debugToggle.style.display = e.target.checked ? 'block' : 'none';
                    if (!e.target.checked) {
                        debugStats.style.display = 'none';
                    }
                });
                debugToggle.addEventListener('click', () => {
                    const isHidden = debugStats.style.display === 'none';
                    debugStats.style.display = isHidden ? 'block' : 'none';
                    if (isHidden) updateDebugStats();
                });
            }

            function applyTheme(isDark) {
                const theme = isDark ? 'dark' : 'light';
                for (const [variable, value] of Object.entries(themeConfig[theme])) {
                    const input = document.querySelector(`[data-variable="${variable}"]`);
                    if (input) {
                        input.value = value;
                        const event = new Event('input', { bubbles: true });
                        input.dispatchEvent(event);
                    } else {
                        // For variables without inputs, like note-outline-color
                        document.documentElement.style.setProperty(variable, value);
                    }
                }
            }
            
            function initializeTabs() {
                const tabsNav = document.getElementById('tabs-nav');
                const tabButtons = tabsNav.querySelectorAll('.tab-btn');
                const tabContents = document.querySelectorAll('aside .tab-content');
                const tabUnderline = document.createElement('div');
                tabUnderline.id = 'tab-underline';
                tabsNav.appendChild(tabUnderline);

                function updateTabUnderline(activeButton) {
                    if (!activeButton) return;
                    tabUnderline.style.width = `${activeButton.offsetWidth}px`;
                    tabUnderline.style.left = `${activeButton.offsetLeft}px`;
                }
                
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        tabContents.forEach(content => content.classList.remove('active'));
                        button.classList.add('active');
                        document.getElementById(`tab-content-${button.dataset.tab}`).classList.add('active');
                        updateTabUnderline(button);
                    });
                });
                
                const initialActiveTab = document.querySelector('.tab-btn.active');
                setTimeout(() => updateTabUnderline(initialActiveTab), 50);
                window.addEventListener('resize', () => {
                    updateTabUnderline(document.querySelector('.tab-btn.active'));
                    createGridLines();
                });
            }

            function initializeMinimizablePanels() {
                document.querySelectorAll('.panel-header').forEach(header => {
                    header.addEventListener('click', () => {
                        const panel = header.closest('.panel');
                        panel.classList.toggle('minimized');
                        const icon = header.querySelector('.toggle-icon');
                        if (icon) icon.textContent = panel.classList.contains('minimized') ? '[+]' : '[-]';
                    });
                });
                // NEW: Make mini-section headers collapsible
                document.querySelectorAll('.mini-section-header').forEach(header => {
                    header.addEventListener('click', () => {
                        header.classList.toggle('minimized');
                        const icon = header.querySelector('.toggle-icon');
                        if(icon) icon.textContent = header.classList.contains('minimized') ? '[+]' : '[-]';
                        
                        let nextEl = header.nextElementSibling;
                        while(nextEl && !nextEl.classList.contains('mini-section-header')) {
                            nextEl.classList.toggle('sub-item-hidden');
                            nextEl = nextEl.nextElementSibling;
                        }
                    });
                });
            }
            
            function initializeModal(modalId, openTriggers, closeTriggers) {
                 const modal = document.getElementById(modalId);
                 if (!modal) return;
                 const close = (e) => {
                     if (e.target === modal || closeTriggers.some(selector => e.target.closest(selector))) {
                         modal.classList.remove('visible');
                     }
                 };
                 openTriggers.forEach(selector => {
                     document.querySelector(selector)?.addEventListener('click', () => modal.classList.add('visible'));
                 });
                 modal.addEventListener('click', close);
            }
            
            function initializeKeybinds() {
                updateKeybindsUI(); // Initial setup
                document.addEventListener('keydown', handleGlobalKeydown);
                document.addEventListener('keyup', handleGlobalKeyup);
            }

            function updateKeybindsUI() {
                const container = document.getElementById('keybind-settings-list');
                container.innerHTML = ''; // Clear existing

                // --- Standard Keybinds ---
                const standardHeader = document.createElement('li');
                standardHeader.className = 'mini-section-header';
                standardHeader.innerHTML = '<span class="toggle-icon">[-]</span>Playback';
                container.appendChild(standardHeader);

                const standardKeybinds = {
                    togglePlay: 'Play/Pause',
                    resetPlayback: 'Reset Playback',
                    gameExit: 'Exit Game Mode'
                };
                for (const [action, label] of Object.entries(standardKeybinds)) {
                    const item = document.createElement('div');
                    item.className = 'keybind-item';
                    const keyText = keybinds[action] === ' ' ? 'Space' : keybinds[action];
                    item.innerHTML = `<label>${label}</label><button class="keybind-btn" data-action="${action}" data-type="standard">${keyText}</button>`;
                    container.appendChild(item);
                }

                // --- NEW: Keyboard Game Keybinds ---
                const kbGameHeader = document.createElement('li');
                kbGameHeader.className = 'mini-section-header';
                kbGameHeader.innerHTML = '<span class="toggle-icon">[-]</span>Keyboard Rhythm Game';
                container.appendChild(kbGameHeader);

                for (let i = 0; i < kbGameNumLanes; i++) {
                    const item = document.createElement('div');
                    item.className = 'keybind-item';
                    const keyText = kbGameKeybinds[i] === ' ' ? 'Space' : (kbGameKeybinds[i] || '...');
                    item.innerHTML = `<label>Lane ${i + 1}</label><button class="keybind-btn" data-lane-index="${i}" data-type="kb-game">${keyText}</button>`;
                    container.appendChild(item);
                }

                // Add event listeners to all buttons
                container.querySelectorAll('.keybind-btn').forEach(btn => {
                    btn.addEventListener('click', () => listenForKey(btn));
                });
            }

            function listenForKey(btn) {
                if (isListeningForKey) return;
                isListeningForKey = true;
                const originalText = btn.textContent;
                btn.textContent = '...';
                btn.classList.add('listening');

                const keydownHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const newKey = e.key;

                    // Unbind the listener immediately
                    document.removeEventListener('keydown', keydownHandler, { capture: true });
                    isListeningForKey = false;
                    btn.classList.remove('listening');

                    // Check for conflicts
                    const allBinds = [...Object.values(keybinds), ...kbGameKeybinds];
                    if (allBinds.some(k => k.toLowerCase() === newKey.toLowerCase())) {
                        alert(`Key "${newKey}" is already bound to another action.`);
                        btn.textContent = originalText;
                        return;
                    }
                    
                    const type = btn.dataset.type;
                    if (type === 'standard') {
                        const action = btn.dataset.action;
                        keybinds[action] = newKey;
                    } else if (type === 'kb-game') {
                        const laneIndex = parseInt(btn.dataset.laneIndex);
                        kbGameKeybinds[laneIndex] = newKey;
                    }

                    btn.textContent = newKey === ' ' ? 'Space' : newKey;
                };

                document.addEventListener('keydown', keydownHandler, { capture: true, once: true });
            }


            function handleGlobalKeydown(e) {
                if (isListeningForKey || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || isSyncing) return;
                const lowerKey = e.key.toLowerCase();
                
                // --- NEW: Keyboard Game Input ---
                if (activeGameMode === 'keyboard' && isPlaying) {
                    const laneIndex = kbGameKeybinds.findIndex(k => k.toLowerCase() === lowerKey);
                    if (laneIndex !== -1 && !kbGamePlayerHeldKeys.has(laneIndex)) {
                        e.preventDefault();
                        kbGame_handleKeyPress(laneIndex);
                    }
                }
                
                if (lowerKey === keybinds.togglePlay.toLowerCase()) {
                    e.preventDefault();
                    if (!playPauseBtn.disabled) togglePlayPause();
                } else if (lowerKey === keybinds.resetPlayback.toLowerCase()) {
                    e.preventDefault();
                    if (activeGameMode !== 'none') {
                        restartGameBtn.click();
                    } else if (midiData) {
                        seekTo(0);
                    }
                } else if (activeGameMode !== 'none' && lowerKey === keybinds.gameExit.toLowerCase()) {
                    e.preventDefault();
                    exitActiveGameMode();
                }
            }
            
            function handleGlobalKeyup(e) {
                 if (isListeningForKey || activeGameMode !== 'keyboard' || !isPlaying) return;
                 const lowerKey = e.key.toLowerCase();
                 const laneIndex = kbGameKeybinds.findIndex(k => k.toLowerCase() === lowerKey);
                 if (laneIndex !== -1) {
                    kbGame_handleKeyRelease(laneIndex);
                 }
            }

            function handleFile(file) {
                if (file && (file.name.endsWith('.mid') || file.name.endsWith('.midi'))) {
                    loadMidiFile(file);
                } else {
                    alert('Please select a valid MIDI file (.mid or .midi)');
                }
            }

async function loadMidiFile(file) {
                if (activeGameMode !== 'none') await exitActiveGameMode();
                loadingOverlay.classList.add('visible');
                playPauseBtn.disabled = true;
                seekBar.disabled = true;
                gameModeBtn.disabled = true;
                if (isPlaying) await togglePlayPause();

                // --- FIX START ---
                // Force-release any held notes from live input and clear sustain state
                if (playerPianoSampler) playerPianoSampler.releaseAll();
                sustainedNotes.clear();
                livePulseElements.forEach(pulseEl => pulseEl.remove());
                livePulseElements.clear();
                // --- FIX END ---

                if (scrollAnimationId) {
                    cancelAnimationFrame(scrollAnimationId);
                    scrollAnimationId = null;
                }
                currentScrollTime = 0;
                scrollTargetTime = 0;
                
                Tone.Transport.seconds = 0;
                currentMidiLoadId++;
                const loadId = currentMidiLoadId;
                
                Tone.Transport.cancel();
                Object.values(audioParts).forEach(part => part?.dispose());
                audioParts = {};
                if (autoPlayPart) autoPlayPart.dispose();
                autoPlayPart = null;

                notesContainer.innerHTML = '';
                pulseContainer.innerHTML = '';
                renderedNoteIds.clear();
                kbGameLaneNotes = []; // Clear processed keyboard notes
                fps = 0;
                
                const fileBuffer = await file.arrayBuffer();
                try { midiData = new Midi(fileBuffer); } 
                catch (e) { alert("Could not parse the MIDI file."); loadingOverlay.classList.remove('visible'); return; }
                
                allNotes = midiData.tracks.flatMap(track => {
                    track.notes.forEach(note => {
                        note.channel = track.channel;
                        // Game state properties
                        note.state = 'pending';
                        note.holdState = 'pending';
                        note.hitTime = -1;
                        note.score = 0;
                    });
                    return track.notes;
                });
                allNotes.forEach((note, index) => note.id = index);
                allNotes.sort((a, b) => a.time - b.time);

                const channels = new Set(allNotes.map(n => n.channel));
                enabledChannels = new Set(channels);
                channelInstruments = {}; 
                channelOrder = [...channels].sort((a, b) => a - b);
                
                const tempo = midiData.header.tempos[0]?.bpm || countdownDefaultTempo;
                preRollDuration = (activeGameMode !== 'none' && isCountdownEnabled) || (activeGameMode === 'none' && isPreRollEnabled) ? (60 / tempo) * 4 : 0;
                
                updateMidiInfo(midiData, allNotes.length, channels);
                createChannelMixer(channels);
                updateFilteredPlayback();
                
                seekBar.max = midiData.duration + preRollDuration;
                updateVisuals(0);
                updateDebugStats(0);
                createGridLines();
                
                accompanimentVolumeControl.style.display = 'flex';
                
                loadingOverlay.classList.remove('visible');
                
                if (isLowLagModeEnabled) {
                    playPauseBtn.disabled = false;
                    seekBar.disabled = false;
                    gameModeBtn.disabled = false;
                } else {
                    runLoadingAnimation(loadId);
                }
            }
            
            async function runLoadingAnimation(loadId) {
                const dimOverlay = document.getElementById('dim-overlay');
                const elementsToBlur = [pulseContainer, notesContainer, pianoContainer];
                const ribbonSvg = document.getElementById('loading-ribbon-svg');
                const ribbonPath = document.getElementById('loading-ribbon-path');

                dimOverlay.classList.add('visible');
                if (showLoadingBlur) elementsToBlur.forEach(el => el.classList.add('loading-blur'));
                
                try {
                    if (loadId !== currentMidiLoadId) return;
                    const text = "Analyzing MIDI...";
                    const loadingTextEl = document.getElementById('loading-text');
                    loadingTextEl.innerHTML = '';
                    text.split('').forEach((char, i) => {
                        const span = document.createElement('span');
                        span.textContent = char === ' ' ? '\u00A0' : char;
                        span.style.setProperty('--i', i);
                        loadingTextEl.appendChild(span);
                    });

                    if (showLoadingRibbon) {
                        ribbonSvg.style.display = 'block';
                        const pathLength = ribbonPath.getTotalLength();
                        ribbonPath.style.strokeDasharray = pathLength;
                        ribbonPath.style.strokeDashoffset = pathLength;
                        ribbonPath.style.animation = 'none';
                        ribbonPath.offsetHeight;
                        ribbonPath.style.animation = `draw-ribbon 2s ease-in-out 0.5s forwards`;
                    }
                    loadingFxContainer.classList.add('visible');
                    await setupVisualizerAsync(loadId);
                    if (loadId !== currentMidiLoadId) return;
                    
                    if (isNoteRevealAnimationEnabled) {
                        let lastPopTime = 0;
                        const observer = new IntersectionObserver((entries) => {
                            entries.forEach(entry => {
                                if (entry.isIntersecting) {
                                    entry.target.classList.add('visible');
                                    const noteName = entry.target.dataset.noteName;
                                    const posX = parseFloat(entry.target.dataset.posX);
                                    const now = Tone.now();
                                    if (now - lastPopTime > 0.02 && noteName && panner) {
                                        panner.pan.rampTo((posX / 50) - 1, 0.01);
                                        popSynth.triggerAttackRelease(noteName, "32n", now);
                                        lastPopTime = now;
                                    }
                                    observer.unobserve(entry.target);
                                }
                            });
                        }, { root: visualizerWrapper, threshold: 0.1 });
                        document.querySelectorAll('.note-visual').forEach(noteEl => observer.observe(noteEl));
                        
                        const revealDistance = visualizerWrapper.offsetHeight * 2;
                        const resetDuration = 500;
                        notesContainer.style.transition = `transform ${noteRevealDuration}ms cubic-bezier(0.25, 0.1, 0.25, 1), filter 0.5s ease-in-out`;
                        notesContainer.style.transform = `translateY(${revealDistance}px)`;
                        await new Promise(resolve => setTimeout(resolve, noteRevealDuration));
                        if (loadId !== currentMidiLoadId) return;
                        
                        loadingFxContainer.classList.remove('visible');
                        notesContainer.style.transition = `transform ${resetDuration}ms cubic-bezier(0.25, 0.1, 0.25, 1), filter 0.5s ease-in-out`;
                        notesContainer.style.transform = `translateY(0px)`;
                        await new Promise(resolve => setTimeout(resolve, resetDuration + 50));
                        notesContainer.style.transition = 'transform 0.1s linear, filter 0.5s ease-in-out';
                        observer.disconnect();
                    }
                    
                    document.querySelectorAll('.note-visual:not(.visible)').forEach(el => el.classList.add('visible'));
                    playPauseBtn.disabled = false;
                    seekBar.disabled = false;
                    gameModeBtn.disabled = false;
                    updateDebugStats();
                } finally {
                    dimOverlay.classList.remove('visible');
                    elementsToBlur.forEach(el => el.classList.remove('loading-blur'));
                    ribbonSvg.style.display = 'none';
                    loadingFxContainer.classList.remove('visible');
                }
            }

            function updateMidiInfo(midi, noteCount, channels) {
                document.querySelector('#midi-info li:nth-child(1) span').textContent = `${Math.round(midi.header.tempos[0].bpm)} BPM`;
                document.querySelector('#midi-info li:nth-child(2) span').textContent = noteCount.toLocaleString();
                document.querySelector('#midi-info li:nth-child(3) span').textContent = channels.size;
            }

            function hexToHue(hex) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; } 
                else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
                r /= 255; g /= 255; b /= 255;
                let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin, h = 0;
                if (delta == 0) h = 0;
                else if (cmax == r) h = ((g - b) / delta) % 6;
                else if (cmax == g) h = (b - r) / delta + 2;
                else h = (r - g) / delta + 4;
                h = Math.round(h * 60);
                if (h < 0) h += 360;
                return h;
            }

            function hslToHex(h, s, l) {
                l /= 100;
                const a = s * Math.min(l, 1 - l) / 100;
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`;
            }

            function redrawNotesWithNewColors() {
                const processNote = (el) => {
                    const noteId = parseInt(el.id.replace('note-visual-', ''));
                    if (isNaN(noteId)) return;
                    const note = allNotes[noteId];
                    if (note) {
                        const noteColor = getColorForNote(note);
                        el.style.backgroundColor = noteColor;

                        applyNoteOutlineStyle(el, note);

                        const label = el.querySelector('.note-label');
                        if (label && noteLabelUseAutomaticColor) {
                            const colors = getContrastingColors(noteColor);
                            label.style.color = colors.fill;
                            label.style.textShadow = `-1px -1px 0 ${colors.outline}, 1px -1px 0 ${colors.outline}, -1px 1px 0 ${colors.outline}, 1px 1px 0 ${colors.outline}`;
                        }
                    }
                };
                if (isLowLagModeEnabled) {
                    for (const el of notesContainer.children) processNote(el);
                } else {
                    document.querySelectorAll('.note-visual').forEach(processNote);
                }
            }

            // MODIFIED: Added draggable functionality
            function createChannelMixer(channels) {
                const list = document.getElementById('channel-mixer-list');
                list.innerHTML = '';
                channelHues = {};
                channelOrder.forEach(ch => {
                    const hue = INITIAL_HUES[ch % INITIAL_HUES.length];
                    channelHues[ch] = hue;
                    const li = document.createElement('li');
                    li.dataset.channel = ch;
                    li.draggable = true;

                    const dragHandle = document.createElement('span');
                    dragHandle.className = 'drag-handle';
                    dragHandle.innerHTML = '&#9776;'; // hamburger icon
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `ch-${ch}`;
                    checkbox.dataset.channel = ch;
                    checkbox.checked = true;
                    checkbox.addEventListener('change', (e) => {
                        const channel = parseInt(e.target.dataset.channel);
                        e.target.checked ? enabledChannels.add(channel) : enabledChannels.delete(channel);
                        updateFilteredPlayback();
                        kbGameLaneNotes = []; // Invalidate keyboard map
                    });
                    const label = document.createElement('label');
                    label.htmlFor = `ch-${ch}`;
                    label.textContent = `Channel ${ch + 1}`;
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.dataset.channel = ch;
                    colorInput.value = hslToHex(hue, 90, 60);
                    colorInput.addEventListener('input', (e) => {
                        const channel = parseInt(e.target.dataset.channel);
                        channelHues[channel] = hexToHue(e.target.value);
                        redrawNotesWithNewColors();
                    });
                    const settingsBtn = document.createElement('button');
                    settingsBtn.className = 'channel-settings-btn';
                    settingsBtn.innerHTML = '&#9881;';
                    settingsBtn.title = `Settings for Channel ${ch + 1}`;
                    settingsBtn.addEventListener('click', () => openChannelSettingsModal(ch));
                    li.append(dragHandle, checkbox, label, colorInput, settingsBtn);
                    list.appendChild(li);
                });

                // Drag and Drop Logic
                let draggedItem = null;
                list.addEventListener('dragstart', (e) => {
                    draggedItem = e.target;
                    setTimeout(() => e.target.classList.add('dragging'), 0);
                });
                list.addEventListener('dragend', (e) => {
                    draggedItem.classList.remove('dragging');
                    draggedItem = null;
                });
                list.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(list, e.clientY);
                    const dragging = document.querySelector('.dragging');
                    if (afterElement == null) {
                        list.appendChild(dragging);
                    } else {
                        list.insertBefore(dragging, afterElement);
                    }
                });
                list.addEventListener('drop', (e) => {
                    e.preventDefault();
                    // Update channelOrder array based on new DOM order
                    channelOrder = Array.from(list.querySelectorAll('li')).map(li => parseInt(li.dataset.channel));
                    updateNoteZIndices();
                });
            }

            function getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
            
            function updateNoteZIndices() {
                if (!midiData) return;
                const zIndexMap = new Map();
                // Higher in the list = higher z-index
                channelOrder.forEach((channel, index) => {
                    zIndexMap.set(channel, channelOrder.length - index);
                });

                document.querySelectorAll('.note-visual').forEach(el => {
                    const channel = parseInt(el.dataset.channel);
                    el.style.zIndex = zIndexMap.get(channel) || 1;
                });
            }
            
            function openChannelSettingsModal(channel) {
                modalTitle.textContent = `Settings for Channel ${channel + 1}`;
                modalBody.innerHTML = ''; 
                const instrumentSetting = document.createElement('div');
                instrumentSetting.className = 'setting-item';
                instrumentSetting.innerHTML = `<label for="instrument-select">Instrument</label><span>Grand Piano</span>`;
                modalBody.appendChild(instrumentSetting);
                if (channel === 9) {
                    instrumentSetting.querySelector('span').textContent = 'Piano / Drums';
                    const drumModeSetting = document.createElement('div');
                    drumModeSetting.className = 'setting-item';
                    const isDrumMode = channelInstruments[9] === 'drums';
                    drumModeSetting.innerHTML = `<label for="drum-mode-toggle">Use Drum Kit</label><input type="checkbox" id="drum-mode-toggle" class="toggle" ${isDrumMode ? 'checked' : ''}>`;
                    modalBody.appendChild(drumModeSetting);
                    drumModeSetting.querySelector('#drum-mode-toggle').addEventListener('change', (e) => {
                        channelInstruments[9] = e.target.checked ? 'drums' : 'piano';
                        updateFilteredPlayback();
                        const drumMapDisplay = modalBody.querySelector('#drum-map-display');
                        if (drumMapDisplay) drumMapDisplay.style.display = e.target.checked ? 'block' : 'none';
                    });
                    const drumMapDisplay = document.createElement('div');
                    drumMapDisplay.id = 'drum-map-display';
                    drumMapDisplay.style.display = isDrumMode ? 'block' : 'none';
                    const listItems = Object.entries(GM_DRUM_MAP).map(([midi, name]) => `<li><strong>${new Tone.Frequency(parseInt(midi), "midi").toNote()}</strong> <span>${name}</span></li>`).join('');
                    drumMapDisplay.innerHTML = `<h3>General MIDI Drum Map</h3><ul>${listItems}</ul>`;
                    modalBody.appendChild(drumMapDisplay);
                }
                modalOverlay.classList.add('visible');
            }

            function closeChannelSettingsModal() {
                modalOverlay.classList.remove('visible');
            }
            
            // --- NEW/REFACTORED: Note Outline Helper Function ---
            function applyNoteOutlineStyle(noteEl, note) {
                noteEl.classList.remove('outline-inward', 'outline-outward', 'outline-center');
                if (!isNoteOutlineEnabled) {
                    noteEl.style.removeProperty('--note-specific-outline-color');
                    return;
                }
                
                noteEl.classList.add(`outline-${noteOutlineStyle}`);
                
                if (noteOutlineUseAutomaticColor) {
                    const baseColor = getColorForNote(note);
                    const darkColor = darkenHsl(baseColor, 20);
                    noteEl.style.setProperty('--note-specific-outline-color', darkColor);
                } else {
                    noteEl.style.removeProperty('--note-specific-outline-color');
                }
            }

            function setupVisualizerAsync(loadId) {
                return new Promise(resolve => {
                    const pianoWidth = pianoContainer.offsetWidth;
                    if (!midiData || isLowLagModeEnabled || pianoWidth === 0) return resolve();
                    notesContainer.innerHTML = '';
                    notesContainer.style.height = `${midiData.duration * noteFallSpeed}px`;
                    const notesToProcess = [...allNotes];
                    const chunkSize = 250;
                    function processChunk() {
                        if (loadId !== currentMidiLoadId || notesToProcess.length === 0) {
                            updateNoteZIndices(); // Apply z-index after all notes are added
                            return resolve();
                        }
                        const fragment = document.createDocumentFragment();
                        const chunk = notesToProcess.splice(0, chunkSize);
                        chunk.forEach(note => {
                           const noteEl = createNoteElement(note, pianoWidth);
                           if (noteEl) fragment.appendChild(noteEl);
                        });
                        notesContainer.appendChild(fragment);
                        setTimeout(processChunk, 0);
                    }
                    processChunk();
                });
            }

            function createNoteElement(note, pianoWidth) {
                 const keyElement = isBlackKey(note.midi) ? blackKeyElements[note.midi] : whiteKeyElements[note.midi];
                 if (!keyElement) return null;
                 const noteDiv = document.createElement('div');
                 noteDiv.className = 'note-visual'; 
                 noteDiv.id = `note-visual-${note.id}`;
                 const keyLeftPercent = (keyElement.offsetLeft / pianoWidth) * 100;
                 noteDiv.dataset.channel = note.channel;
                 noteDiv.dataset.noteName = note.name;
                 noteDiv.dataset.posX = keyLeftPercent;
                 noteDiv.style.left = `${keyLeftPercent}%`;
                 noteDiv.style.width = `${(keyElement.offsetWidth / pianoWidth) * 100}%`;
                 noteDiv.style.bottom = `${note.time * noteFallSpeed}px`;
                 noteDiv.style.height = `${Math.max(2, note.duration * noteFallSpeed)}px`;
                 const noteColor = getColorForNote(note);
                 noteDiv.style.backgroundColor = noteColor;
                 noteDiv.style.display = enabledChannels.has(note.channel) ? 'block' : 'none';
                 // Set initial z-index based on current channel order
                 noteDiv.style.zIndex = channelOrder.length - channelOrder.indexOf(note.channel);
                 
                 // REFACTORED: Use helper for outlines
                 applyNoteOutlineStyle(noteDiv, note);

                if (isNoteLabelModeEnabled) {
                    const label = document.createElement('span');
                    label.className = 'note-label';
                    label.classList.add(`note-label-${noteLabelOrientation}`);
                    label.classList.add(`note-label-pos-${noteLabelPosition}`);
                    
                    label.textContent = noteLabelShowOctave ? note.name : note.name.replace(/\d/g, '');

                    if (noteLabelUseAutomaticColor) {
                        const colors = getContrastingColors(noteColor);
                        label.style.color = colors.fill;
                        label.style.textShadow = `-1px -1px 0 ${colors.outline}, 1px -1px 0 ${colors.outline}, -1px 1px 0 ${colors.outline}, 1px 1px 0 ${colors.outline}`;
                    }
                    noteDiv.appendChild(label);
                }
                
                 return noteDiv;
            }
            
            function triggerKeyPulse(note) {
                const keyEl = document.getElementById(`key-${note.midi}`);
                if (!keyEl) return;

                const pulseEl = document.createElement('div');
                pulseEl.className = 'key-pulse-visual';
                pulseEl.style.backgroundColor = getColorForNote(note);
                pulseEl.style.animationDuration = `${note.duration}s`;
                
                pulseEl.addEventListener('animationend', () => {
                    const parentKey = pulseEl.parentElement;
                    pulseEl.remove();
                    if (isDividedPulseEnabled && parentKey) {
                        const remainingPulses = parentKey.querySelectorAll('.key-pulse-visual');
                        if (remainingPulses.length > 0) {
                            const newHeight = 100 / remainingPulses.length;
                            remainingPulses.forEach((p, index) => {
                                p.style.height = `${newHeight}%`;
                                p.style.top = `${index * newHeight}%`;
                            });
                        }
                    }
                }, { once: true });

                if (isDividedPulseEnabled) {
                    const existingPulses = keyEl.querySelectorAll('.key-pulse-visual');
                    const newTotal = existingPulses.length + 1;
                    const newHeight = 100 / newTotal;

                    existingPulses.forEach((p, index) => {
                        p.style.height = `${newHeight}%`;
                        p.style.top = `${index * newHeight}%`;
                    });
                    
                    pulseEl.style.height = `${newHeight}%`;
                    pulseEl.style.top = `${existingPulses.length * newHeight}%`;
                } else {
                    pulseEl.style.height = '100%';
                    pulseEl.style.top = '0';
                }

                keyEl.appendChild(pulseEl);
            }

            function triggerColumnPulse(note) {
                if (!isPulseEnabled) return;
                const keyElement = isBlackKey(note.midi) ? blackKeyElements[note.midi] : whiteKeyElements[note.midi];
                if (!keyElement) return;
                const pulseEl = document.createElement('div');
                pulseEl.className = 'pulse-column';
                pulseEl.style.left = `${(keyElement.offsetLeft / pianoContainer.offsetWidth) * 100}%`;
                pulseEl.style.width = `${(keyElement.offsetWidth / pianoContainer.offsetWidth) * 100}%`;
                
                const basePulseColor = useNoteColorForPulse ? getColorForNote(note) : customPulseColor;
                const {r, g, b} = colorToRgba(basePulseColor);
                const finalPulseColor = `rgba(${r}, ${g}, ${b}, ${pulseOpacity})`;

                pulseEl.style.setProperty('--pulse-color', finalPulseColor);
                pulseContainer.appendChild(pulseEl);
                setTimeout(() => pulseEl.remove(), pulseDuration * 1000);
            }

            function updateFilteredPlayback() {
                const wasPlaying = isPlaying;
                if (wasPlaying) Tone.Transport.pause();
                Object.values(audioParts).forEach(part => part?.dispose());
                audioParts = {};
                if (pianoSampler) pianoSampler.releaseAll();
                if (drumSampler) drumSampler.releaseAll();

                const filteredNotes = allNotes.filter(note => enabledChannels.has(note.channel));
                const pianoNotes = filteredNotes.filter(note => channelInstruments[note.channel] !== 'drums');
                const drumNotes = filteredNotes.filter(note => channelInstruments[note.channel] === 'drums');
                
            // MODIFIED
            const partCallback = (time, note) => {
                 Tone.Draw.schedule(() => {
                    triggerColumnPulse(note);
                    // Highlight keys in normal mode OR in auto-play game mode
                    if (activeGameMode === 'none' || (activeGameMode === 'midi' && isAutoPlay)) {
                        triggerKeyPulse(note);
                    }
                }, time);
            };

                if (pianoNotes.length > 0) {
                    audioParts.piano = new Tone.Part((time, note) => {
                        pianoSampler.triggerAttackRelease(note.name, note.duration, time, note.velocity);
                        partCallback(time, note);
                    }, pianoNotes).start(preRollDuration);
                }
                if (drumNotes.length > 0) {
                     audioParts.drums = new Tone.Part((time, note) => {
                        drumSampler.triggerAttackRelease(note.name, note.duration, time, note.velocity);
                        partCallback(time, note);
                    }, drumNotes).start(preRollDuration);
                }

                document.querySelectorAll('.note-visual').forEach(el => {
                    el.style.display = enabledChannels.has(parseInt(el.dataset.channel)) ? 'block' : 'none';
                });
                if (wasPlaying) Tone.Transport.start();
            }

            function startCountdown() {
                const tempo = midiData?.header.tempos[0]?.bpm || countdownDefaultTempo;
                const beatDuration = 60 / tempo;

                resetGame();
                if (isAutoPlay) setupAutoPlay();
                playPauseBtn.disabled = true;
                countdownOverlay.style.display = 'flex';

                for (let i = 0; i < 4; i++) {
                    Tone.Transport.scheduleOnce(time => {
                        const count = 4 - i;
                        countdownText.textContent = count;
                        calMetronome.triggerAttack(i === 0 ? "G4" : "C4", time, 0.8);
                        countdownText.classList.remove('countdown-pop-animation');
                        void countdownText.offsetWidth;
                        countdownText.classList.add('countdown-pop-animation');
                    }, i * beatDuration);
                }

                Tone.Transport.scheduleOnce(time => {
                    countdownOverlay.style.display = 'none';
                    isPlaying = true;
                    gameSessionActive = true;
                    playPauseBtn.innerHTML = pauseIcon;
                    playPauseBtn.disabled = false;
                }, 4 * beatDuration);

                Tone.Transport.start();
                animationFrameId = requestAnimationFrame(animationLoop);
            }

            async function togglePlayPause() {
                if (scrollAnimationId) {
                    cancelAnimationFrame(scrollAnimationId);
                    scrollAnimationId = null;
                }
                currentScrollTime = Tone.Transport.seconds;
                scrollTargetTime = Tone.Transport.seconds;

                if (!midiData || !pianoSampler) return;
                if (Tone.context.state !== 'running') await Tone.start();
                
                if (activeGameMode !== 'none' && !isPlaying && !gameSessionActive && isCountdownEnabled) {
                    startCountdown();
                    return;
                }
                
                if (activeGameMode !== 'none' && !isPlaying && !gameSessionActive) {
                    resetGame();
                    gameSessionActive = true;
                }

                isPlaying = !isPlaying;
                playPauseBtn.innerHTML = isPlaying ? pauseIcon : playIcon;
                if (isPlaying) {
                    Tone.Transport.start();
                    animationFrameId = requestAnimationFrame(animationLoop);
                } else {
                    Tone.Transport.pause();
                    cancelAnimationFrame(animationFrameId);
                    document.querySelectorAll('.key-pulse-visual').forEach(el => el.remove());
                    if (pianoSampler) pianoSampler.releaseAll();
                    if (drumSampler) drumSampler.releaseAll();
                    if (playerPianoSampler) playerPianoSampler.releaseAll();
                    
                    // --- FIX START ---
                    // Clear internal state for sustain and visuals on pause
                    sustainedNotes.clear();
                    livePulseElements.forEach(pulseEl => pulseEl.remove());
                    livePulseElements.clear();
                    // --- FIX END ---
                    
                    if (activeGameMode === 'midi') {
                        playerHeldNotes.forEach(heldInfo => {
                            handleNoteRelease(heldInfo.gameNote.midi);
                        });
                        playerHeldNotes.clear();
                    } else if (activeGameMode === 'keyboard') {
                         kbGamePlayerHeldKeys.forEach((heldInfo, laneIndex) => {
                            kbGame_handleKeyRelease(laneIndex, true); // Force release on pause
                        });
                        kbGamePlayerHeldKeys.clear();
                    }


                    updateVisuals(Tone.Transport.seconds);
                    fps = 0;
                    updateDebugStats();
                }
            }
            
            function updateVisuals(time) {
                if (!midiData) return;
                seekBar.value = time;
                const songTime = time - preRollDuration;
                timeDisplay.textContent = `${formatTime(Math.max(0, songTime))} / ${formatTime(midiData.duration)}`;
                
                if (activeGameMode === 'keyboard') {
                    kbGame_updateVisuals(songTime);
                } else {
                    notesContainer.style.transform = `translateY(${songTime * noteFallSpeed}px)`;
                    if (isLowLagModeEnabled) {
                        updateVisibleNotes(songTime);
                    }
                    updateActiveState(songTime);
                }
            }

            function updateVisibleNotes(currentTime) {
                const viewHeight = visualizerWrapper.offsetHeight;
                const visibleDuration = viewHeight / noteFallSpeed;
                const viewStartTime = currentTime - (visibleDuration * 0.1);
                const viewEndTime = currentTime + visibleDuration * 1.1;
                const pianoWidth = pianoContainer.offsetWidth;
                const shouldBeVisibleIds = new Set();
                const fragment = document.createDocumentFragment();

                for (const note of allNotes) {
                    const noteEndTime = note.time + note.duration;
                    if (noteEndTime >= viewStartTime && note.time <= viewEndTime) {
                        shouldBeVisibleIds.add(note.id);
                        if (!renderedNoteIds.has(note.id)) {
                            const noteEl = createNoteElement(note, pianoWidth);
                            if (noteEl) {
                                if (activeGameMode === 'midi') {
                                    noteEl.classList.add('pending');
                                    if (note.state === 'miss') noteEl.classList.add('missed');
                                    else if (note.state === 'hit') noteEl.classList.add('hit');
                                }
                                fragment.appendChild(noteEl);
                            }
                            renderedNoteIds.add(note.id);
                        }
                    }
                }
                if (fragment.childElementCount > 0) {
                    const newElements = Array.from(fragment.children);
                    notesContainer.appendChild(fragment);
                    requestAnimationFrame(() => newElements.forEach(el => el.classList.add('visible')));
                }
                renderedNoteIds.forEach(id => {
                    if (!shouldBeVisibleIds.has(id)) {
                        document.getElementById(`note-visual-${id}`)?.remove();
                        renderedNoteIds.delete(id);
                    }
                });
            }

            function updateActiveState(currentTime) {
                if (activeGameMode !== 'none') return;

                if (!isPlaying) {
                    activeVisuals.forEach(noteId => {
                         const visual = document.getElementById(`note-visual-${noteId}`);
                         if (visual) visual.classList.remove('active-visual');
                    });
                    activeVisuals.clear();
                    return;
                }

                const shouldBeActiveNotes = new Map();
                if (!midiData) return;

                allNotes.forEach(note => {
                    if (enabledChannels.has(note.channel) && currentTime >= note.time && currentTime < note.time + note.duration) {
                        shouldBeActiveNotes.set(note.id, note);
                    }
                });
                
                shouldBeActiveNotes.forEach((note, noteId) => {
                    if (!activeVisuals.has(noteId)) {
                        document.getElementById(`note-visual-${noteId}`)?.classList.add('active-visual');
                        activeVisuals.add(noteId);
                    }
                });

                activeVisuals.forEach(noteId => {
                    if (!shouldBeActiveNotes.has(noteId)) {
                        document.getElementById(`note-visual-${noteId}`)?.classList.remove('active-visual');
                    }
                });
                
                activeVisuals = new Set(shouldBeActiveNotes.keys());
            }

            function startSmoothScroll() {
                if (scrollAnimationId) return; 

                if (pauseOnScroll && isPlaying) {
                    togglePlayPause();
                }
                if (pianoSampler) pianoSampler.releaseAll();
                if (drumSampler) drumSampler.releaseAll();

                function scrollLoop() {
                    const distance = scrollTargetTime - currentScrollTime;
                    if (Math.abs(distance) < 0.001) {
                        currentScrollTime = scrollTargetTime;
                        Tone.Transport.seconds = currentScrollTime;
                        updateVisuals(currentScrollTime);
                        updateDebugStats(currentScrollTime);
                        scrollAnimationId = null;
                        return;
                    }
                    currentScrollTime += distance * scrollLerpFactor;
                    Tone.Transport.seconds = currentScrollTime;
                    seekBar.value = currentScrollTime;
                    updateVisuals(currentScrollTime);
                    updateDebugStats(currentScrollTime);
                    scrollAnimationId = requestAnimationFrame(scrollLoop);
                }
                scrollAnimationId = requestAnimationFrame(scrollLoop);
            }

            function seekTo(newTime) {
                if (scrollAnimationId) {
                    cancelAnimationFrame(scrollAnimationId);
                    scrollAnimationId = null;
                }
                if (!midiData) return;
                const clampedTime = Math.max(0, Math.min(newTime, midiData.duration + preRollDuration));
                currentScrollTime = clampedTime;
                scrollTargetTime = clampedTime;
                Tone.Transport.seconds = clampedTime;
                seekBar.value = clampedTime;
                if (pianoSampler) pianoSampler.releaseAll();
                if (drumSampler) drumSampler.releaseAll();

                // --- FIX START ---
                // Also release player notes and clear sustain state when seeking
                if (playerPianoSampler) playerPianoSampler.releaseAll();
                sustainedNotes.clear();
                livePulseElements.forEach(pulseEl => pulseEl.remove());
                livePulseElements.clear();
                // --- FIX END ---

                if (isLowLagModeEnabled) {
                    notesContainer.innerHTML = '';
                    renderedNoteIds.clear();
                    if(kbGameNotesContainer) kbGameNotesContainer.innerHTML = '';
                    kbGameRenderedNoteIds.clear();
                }
                if (!isPlaying) {
                   updateVisuals(clampedTime);
                }
            }

            function updateDebugStats(time) {
                if (debugStats.style.display !== 'none') {
                    const currentTime = (time !== undefined ? time : (scrollAnimationId ? currentScrollTime : Tone.Transport.seconds));
                    debugStats.innerHTML = `
                        Time: ${currentTime.toFixed(2)}s<br>
                        Song Time: ${(currentTime - preRollDuration).toFixed(2)}s<br>
                        FPS: ${Math.round(fps)}<br>
                        Rendered Notes: ${notesContainer.childElementCount + (kbGameNotesContainer?.childElementCount || 0)}<br>
                        Active Visuals: ${activeVisuals.size}<br>
                        Low Lag Mode: ${isLowLagModeEnabled}<br>
                        Game Mode: ${activeGameMode}<br>
                        Held Note Status: ${lastHeldNoteStatus}
                    `.trim().replace(/^\s+/gm, '');
                }
            }
            
function animationLoop() {
                if (!midiData) { cancelAnimationFrame(animationFrameId); return; }
                const currentTime = Tone.Transport.seconds;
                const now = performance.now();
                const delta = now - lastFrameTime;
                if (delta > 0) fps = 1000 / delta; 
                lastFrameTime = now;
                
                if (isGuidanceModeEnabled && isPlaying && midiData && activeGameMode !== 'keyboard') {
                    // ... (guidance logic is unchanged)
                } else if (guidedKeys.size > 0) {
                    // ... (guidance logic is unchanged)
                }

                if (gameSessionActive && isPlaying && !isAutoPlay) {
                    if (activeGameMode === 'midi') {
                        playerHeldNotes.forEach((heldInfo, midi) => {
                            const { gameNote } = heldInfo;
                            const noteEndTimeInTransport = gameNote.time + gameNote.duration + preRollDuration;
                            // Check for over-hold
                            if(currentTime > noteEndTimeInTransport + globalOffset + overholdPenaltyWindow) {
                                // This is the first frame of over-hold
                                if (!heldInfo.isOverheld) {
                                    heldInfo.isOverheld = true;
                                    // Mark the original note as a miss to penalize accuracy stats once
                                    markNoteAsMiss(gameNote);
                                    showJudgement('Miss', '#f44336');
                                }
                                // Continuous penalty logic
                                gameStats.combo = 0;
                                const penalty = (delta / 1000) * holdScorePerSecond * 1.5; // Penalty is 1.5x the scoring rate
                                gameStats.score = Math.max(0, gameStats.score - penalty);
                        
                                // Visual feedback for over-hold
                                const noteEl = document.getElementById(`note-visual-${gameNote.id}`);
                                if (noteEl) noteEl.classList.add('missed'); // Use the 'missed' style to indicate penalty
                        
                            } else {
                                // Scoring for a correctly held note
                                const holdPoints = (delta / 1000) * holdScorePerSecond;
                                gameStats.score += holdPoints;
                            }
                        });


                        allNotes.forEach(note => {
                            const noteTimeInTransport = note.time + preRollDuration;
                            if (note.state === 'pending' && currentTime > (noteTimeInTransport + globalOffset) + missWindow && enabledChannels.has(note.channel)) {
                               markNoteAsMiss(note);
                            }
                        });
                    } else if (activeGameMode === 'keyboard') {
                         kbGamePlayerHeldKeys.forEach((heldInfo, laneIndex) => {
                            const { gameNote } = heldInfo;
                            const noteEndTimeInTransport = gameNote.time + gameNote.duration + preRollDuration;
                            // Check for over-hold
                            if (currentTime > noteEndTimeInTransport + globalOffset + overholdPenaltyWindow) {
                                const noteEl = document.getElementById(`kb-note-${gameNote.id}`);
                                // This is the first frame of over-hold
                                if (!heldInfo.isOverheld) {
                                    heldInfo.isOverheld = true;
                                     // Mark the original note as a miss to penalize accuracy stats once
                                    kbGame_markNoteAsMiss(gameNote);
                                    showJudgement('Miss', '#f44336');
                                }
                                // Continuous penalty logic
                                gameStats.combo = 0;
                                const penalty = (delta / 1000) * holdScorePerSecond * 1.5; // Penalty is 1.5x scoring rate
                                gameStats.score = Math.max(0, gameStats.score - penalty);
                        
                                // Visual feedback for over-hold
                                if (noteEl) {
                                     noteEl.classList.remove('active-hold'); // remove glow
                                     noteEl.classList.add('missed'); // add missed styling
                                }
                                const indicator = document.getElementById(`kb-key-indicator-${laneIndex}`);
                                // Make the key indicator flash or turn red
                                if (indicator) indicator.style.backgroundColor = '#f44336';
                        
                        
                            } else {
                                // Scoring for a correctly held note
                                const holdPoints = (delta / 1000) * holdScorePerSecond;
                                gameStats.score += holdPoints;
                            }
                        });


                        kbGameLaneNotes.flat().forEach(note => {
                            const noteTimeInTransport = note.time + preRollDuration;
                            if (note.state === 'pending' && currentTime > (noteTimeInTransport + globalOffset) + missWindow) {
                               kbGame_markNoteAsMiss(note);
                            }
                        });
                    }
                    updateHUD();
                }

                updateDebugStats(currentTime);
                updateVisuals(currentTime);

                if (isPlaying && gameEndingState === 0 && currentTime >= midiData.duration + preRollDuration) {
                    if (activeGameMode !== 'none') {
                        gameEndingState = 1;
                        const endTime = Tone.Transport.seconds;
                        Tone.Transport.scheduleOnce(time => {
                            if (activeGameMode === 'midi') {
                                playerHeldNotes.forEach(heldInfo => handleNoteRelease(heldInfo.gameNote.midi));
                            } else if (activeGameMode === 'keyboard') {
                                kbGamePlayerHeldKeys.forEach((heldInfo, laneIndex) => kbGame_handleKeyRelease(laneIndex, true));
                            }
                            showResults();
                            if (isPlaying) togglePlayPause();
                            seekTo(0);
                        }, endTime + 1);
                    } else {
                        togglePlayPause();
                        seekTo(0);
                    }
                }
                if(isPlaying || countdownOverlay.style.display === 'flex') animationFrameId = requestAnimationFrame(animationLoop);
            }

            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60);
                return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }

            function initializeMidiInput() {
                const midiSelect = document.getElementById('midi-input-select');
                const midiStatus = document.getElementById('midi-status');
                midiSelect.addEventListener('click', () => {
                    if (!navigator.requestMIDIAccess) {
                        midiStatus.textContent = 'Web MIDI API not supported.';
                        return;
                    }
                    midiStatus.textContent = 'Requesting MIDI access...';
                    navigator.requestMIDIAccess({ sysex: false }).then(onMIDISuccess, onMIDIFailure);
                }, { once: true });
                function onMIDISuccess(midiAccess) {
                    const inputs = [...midiAccess.inputs.values()];
                    midiSelect.innerHTML = '';
                    if (inputs.length > 0) {
                        inputs.forEach(input => {
                            const option = document.createElement('option');
                            option.value = input.id; option.textContent = input.name;
                            midiSelect.appendChild(option);
                        });
                        midiStatus.textContent = 'Select a device to begin.';
                        midiSelect.addEventListener('change', () => connectMidiDevice(midiAccess));
                        connectMidiDevice(midiAccess);
                    } else {
                        midiStatus.textContent = 'No MIDI devices found.';
                        midiSelect.innerHTML = '<option>No devices found</option>';
                    }
                }
                function onMIDIFailure() { midiStatus.textContent = 'Could not access MIDI devices.'; }
                function connectMidiDevice(midiAccess) {
                    if (liveMidiInput) liveMidiInput.onmidimessage = null;
                    liveMidiInput = midiAccess.inputs.get(midiSelect.value);
                    if (liveMidiInput) {
                        liveMidiInput.onmidimessage = onMIDIMessage;
                        midiStatus.textContent = `Connected to ${liveMidiInput.name}.`;
                    }
                }
async function onMIDIMessage(message) {
                    if (Tone.context.state !== 'running') await Tone.start();
                    const [command, data1, data2] = message.data;
                    const commandType = command & 0xF0, channel = command & 0x0F, noteMidi = data1, velocity = data2 / 127;
                    const noteName = new Tone.Frequency(noteMidi, "midi").toNote();
                    
                    if (isSyncing) {
                        if (commandType === 0x90 && velocity > 0) {
                            handleSyncTap();
                        }
                        return;
                    }
                    
                    if (!playerPianoSampler) return;
                    
                    if (activeGameMode === 'midi' && !isAutoPlay) {
                        if (commandType === 0x90 && velocity > 0) {
                            playerPianoSampler.triggerAttack(noteName, Tone.now(), velocity);
                            if (isPlaying) checkPlayerHit(noteMidi, velocity);
                            const pNote = { midi: noteMidi, velocity: velocity, channel: 10, duration: 0.5 };
                            triggerKeyPulse(pNote);
                            triggerColumnPulse(pNote);
                        } else if (commandType === 0x80 || (commandType === 0x90 && velocity === 0)) {
                            playerPianoSampler.triggerRelease(noteName, Tone.now());
                            if (isPlaying) handleNoteRelease(noteMidi);
                        }
                        return;
                    } else if (activeGameMode === 'keyboard' && !isAutoPlay) { // <-- ADD THIS ENTIRE 'ELSE IF' BLOCK
                        if (commandType === 0x90 && velocity > 0) {
                            // Find the best note to hit based on the MIDI input and trigger it
                            const gameNote = kbGame_checkPlayerHit_fromMidi(noteMidi, velocity);
                            if (gameNote) {
                                // If a valid note was hit, play its sound and map it for release
                                playerPianoSampler.triggerAttack(noteName, Tone.now(), velocity);
                                midiToLaneMap.set(noteMidi, gameNote.lane);
                            }
                        } else if (commandType === 0x80 || (commandType === 0x90 && velocity === 0)) {
                            // If this MIDI note was holding down a lane, release it
                            if (midiToLaneMap.has(noteMidi)) {
                                const laneIndex = midiToLaneMap.get(noteMidi);
                                kbGame_handleKeyRelease(laneIndex);
                                playerPianoSampler.triggerRelease(noteName, Tone.now());
                                midiToLaneMap.delete(noteMidi);
                            }
                        }
                        return; // Prevent fall-through to normal mode logic
                    }


                    if (commandType === 0xB0 && noteMidi === 64) { // Sustain pedal
                        isSustainOn = data2 >= 64;
                        if (!isSustainOn) {
                            sustainedNotes.forEach(noteToRelease => {
                                const midiNum = new Tone.Frequency(noteToRelease).toMidi();
                                playerPianoSampler.triggerRelease(noteToRelease, Tone.now()); // FIX: Use player sampler
                                if (livePulseElements.has(midiNum)) {
                                    const pulseEl = livePulseElements.get(midiNum);
                                    pulseEl.style.animationDuration = '0.3s';
                                    livePulseElements.delete(midiNum);
                                }
                            });
                            sustainedNotes.clear();
                        }
                        return;
                    }

                    // --- FIX: Route normal mode live input to playerPianoSampler ---
                    if (commandType === 0x90 && velocity > 0) {
                        playerPianoSampler.triggerAttack(noteName, Tone.now(), velocity);

                        if (livePulseElements.has(noteMidi)) {
                            livePulseElements.get(noteMidi).remove();
                        }
                        const keyEl = document.getElementById(`key-${noteMidi}`);
                        if (keyEl) {
                            const pulseEl = document.createElement('div');
                            pulseEl.className = 'key-pulse-visual';
                            // Use a default channel for coloring since live input doesn't have one from a file
                            pulseEl.style.backgroundColor = getColorForNote({ midi: noteMidi, velocity, channel: 10 });
                            pulseEl.style.animationDuration = '10s'; // Long duration, cut short on release
                            pulseEl.addEventListener('animationend', () => pulseEl.remove(), { once: true });
                            keyEl.appendChild(pulseEl);
                            livePulseElements.set(noteMidi, pulseEl);
                        }
                        triggerColumnPulse({ midi: noteMidi, velocity, channel: 10 });
                        
                    } else if (commandType === 0x80 || (commandType === 0x90 && velocity === 0)) {
                        if (isSustainOn) {
                            sustainedNotes.add(noteName);
                        } else {
                            playerPianoSampler.triggerRelease(noteName, Tone.now());
                            if (livePulseElements.has(noteMidi)) {
                                const pulseEl = livePulseElements.get(noteMidi);
                                pulseEl.style.animationDuration = '0.3s'; // Triggers fade out and removal
                                livePulseElements.delete(noteMidi);
                            }
                        }
                    }
                }
            }
            

            // --- REVISED AND FINAL: Tutorial Functions ---
            let isTutorialTransitioning = false;

            /**
             * Ensures an element is fully visible by handling tabs, collapsed panels, and scrolling.
             * @param {object} step The tutorial step object.
             * @returns {Promise<HTMLElement|null>} A promise that resolves with the target element if it was made visible, or null if not found.
             */
            function ensureElementIsVisible(step) {
                return new Promise(resolve => {
                    // 1. Handle Tab Switching
                    const tabId = step.tab;
                    const tabButton = tabId ? document.querySelector(`.tab-btn[data-tab="${tabId}"]`) : null;
                    const needsTabSwitch = tabButton && !tabButton.classList.contains('active');

                    if (needsTabSwitch) {
                        tabButton.click();
                    }

                    // Wait for tab animation before proceeding
                    setTimeout(() => {
                        const targetElement = document.querySelector(step.element);
                        if (!targetElement) {
                            resolve(null);
                            return;
                        }

                        // 2. Handle Collapsed Main Panels
                        const parentPanel = targetElement.closest('.panel.minimized');
                        if (parentPanel) {
                            parentPanel.querySelector('.panel-header').click();
                        }

                        // 3. Handle Collapsed Mini-Sections within panels
                        // We traverse previous siblings from the element's list item to find its header
                        let currentEl = targetElement.closest('li');
                        if (currentEl) {
                            let sibling = currentEl.previousElementSibling;
                            while(sibling) {
                                if (sibling.classList.contains('mini-section-header')) {
                                    if (sibling.classList.contains('minimized')) {
                                        sibling.click();
                                    }
                                    break; // Found the header for this section
                                }
                                sibling = sibling.previousElementSibling;
                            }
                        }
                        
                        // 4. Scroll element into view
                        // A short delay allows expand animations to start before scrolling
                        setTimeout(() => {
                            const scrollParent = document.getElementById('aside-scroll-wrapper');
                            // We calculate the scroll position manually for more control
                            const targetRect = targetElement.getBoundingClientRect();
                            const parentRect = scrollParent.getBoundingClientRect();
                            
                            const scrollOffset = (targetRect.top - parentRect.top) - (parentRect.height / 2) + (targetRect.height / 2);

                            scrollParent.scrollTo({
                                top: scrollParent.scrollTop + scrollOffset,
                                behavior: 'smooth'
                            });

                            // Resolve after the smooth scroll has had time to complete
                            setTimeout(() => resolve(targetElement), 400);
                        }, 50);

                    }, needsTabSwitch ? 350 : 0);
                });
            }

            async function startTutorial() {
                if (tutorialActive) return;
                tutorialActive = true;
                currentTutorialStep = 0;

                // Ensure the 'General' tab is active before starting.
                const generalTab = document.querySelector('.tab-btn[data-tab="general"]');
                if(generalTab && !generalTab.classList.contains('active')) generalTab.click();

                // Wait for any potential tab switch before getting the element's position.
                setTimeout(async () => {
                    const firstStepElement = await ensureElementIsVisible(tutorialSteps[0]);
                    if (firstStepElement) {
                        const rect = firstStepElement.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const vw = window.innerWidth, vh = window.innerHeight;
                        const initialClipPath = `polygon(evenodd, 0px 0px, ${vw}px 0px, ${vw}px ${vh}px, 0px ${vh}px, 0px 0px, ${centerX}px ${centerY}px, ${centerX}px ${centerY}px, ${centerX}px ${centerY}px, ${centerX}px ${centerY}px, ${centerX}px ${centerY}px)`;
                        tutorialOverlay.style.clipPath = initialClipPath;
                    }
                    
                    requestAnimationFrame(() => {
                        tutorialOverlay.classList.add('visible');
                        showTutorialStep(0);
                    });
                    
                    window.addEventListener('resize', updateTutorialStepPosition);
                }, 350);
            }

            function endTutorial() {
                tutorialActive = false;
                tutorialOverlay.classList.remove('visible');
                tutorialCaptionBox.classList.remove('visible');
                window.removeEventListener('resize', updateTutorialStepPosition);
            }

            function updateTutorialStepPosition() {
                if (tutorialActive) {
                    const oldTransition = tutorialOverlay.style.transition;
                    tutorialOverlay.style.transition = 'none';
                    showTutorialStep(currentTutorialStep, false); // false = don't animate caption
                    requestAnimationFrame(() => {
                        tutorialOverlay.style.transition = oldTransition;
                    });
                }
            }

            async function showTutorialStep(index, animateCaption = true) {
                if (isTutorialTransitioning && animateCaption) return;
                if (index < 0 || index >= tutorialSteps.length) {
                    endTutorial();
                    return;
                }
                
                isTutorialTransitioning = true;
                currentTutorialStep = index;
                const step = tutorialSteps[index];
                
                tutorialCaptionBox.classList.remove('visible');
                
                // 1. Ensure the element is visible on screen (handles tabs, collapses, scrolling)
                const targetElement = await ensureElementIsVisible(step);
                
                if (!targetElement) {
                    console.warn(`Tutorial element could not be made visible: ${step.element}`);
                    isTutorialTransitioning = false;
                    showTutorialStep(index + 1); // Skip to the next step
                    return;
                }
                
                // 2. Move the silhouette to the now-visible target.
                const rect = targetElement.getBoundingClientRect();
                const padding = 8;
                const x1 = rect.left - padding, y1 = rect.top - padding;
                const x2 = rect.right + padding, y2 = rect.bottom + padding;
                const vw = window.innerWidth, vh = window.innerHeight;

                const clipPathValue = `polygon(evenodd, 0px 0px, ${vw}px 0px, ${vw}px ${vh}px, 0px ${vh}px, 0px 0px, ${x1}px ${y1}px, ${x2}px ${y1}px, ${x2}px ${y2}px, ${x1}px ${y2}px, ${x1}px ${y1}px)`;
                tutorialOverlay.style.clipPath = clipPathValue;

                // 3. After the silhouette has started moving, update and show the new caption.
                setTimeout(() => {
                    tutorialTitle.textContent = step.title;
                    tutorialText.textContent = step.text;
                    tutorialStepCounter.textContent = `${index + 1} / ${tutorialSteps.length}`;
                    tutorialPrevBtn.style.display = index === 0 ? 'none' : 'inline-block';
                    tutorialNextBtn.textContent = index === tutorialSteps.length - 1 ? 'Finish' : 'Next';

                    // Positioning logic
                    tutorialCaptionBox.style.left = `${rect.left + rect.width / 2}px`;
                    if (step.position === 'top' || rect.bottom + tutorialCaptionBox.offsetHeight + 20 > window.innerHeight) {
                        tutorialCaptionBox.style.top = 'auto';
                        tutorialCaptionBox.style.bottom = `${window.innerHeight - rect.top + 15}px`;
                    } else {
                        tutorialCaptionBox.style.bottom = 'auto';
                        tutorialCaptionBox.style.top = `${rect.bottom + 15}px`;
                    }
                    
                    let transform = `translateX(-50%)`;
                    // Use a temporary clone to calculate dimensions without affecting the real one
                    const tempCaption = tutorialCaptionBox.cloneNode(true);
                    tempCaption.style.visibility = 'hidden';
                    document.body.appendChild(tempCaption);
                    const captionWidth = tempCaption.offsetWidth;
                    document.body.removeChild(tempCaption);

                    const finalLeft = (rect.left + rect.width / 2) - (captionWidth / 2);
                    const finalRight = finalLeft + captionWidth;

                    if (finalRight > window.innerWidth - 10) transform = `translateX(calc(-100% + ${rect.width/2}px + ${padding}px))`;
                    if (finalLeft < 10) transform = `translateX(calc(0% - ${rect.width/2}px + ${padding}px))`;
                    tutorialCaptionBox.style.transform = transform;
                    
                    if(animateCaption) {
                        tutorialCaptionBox.classList.add('visible');
                    }
                    isTutorialTransitioning = false;
                }, 250);
            }

            // --- Game Mode Functions ---
            function initializeGameSettings() {
                const difficultySelect = document.getElementById('difficulty-select');
                const gameTweakSliders = document.querySelectorAll('[data-gametweak]');
                const customDifficultySliders = document.querySelectorAll('[data-gametweak], #timing-window-slider');
                let isUpdatingFromPreset = false;

                function updateDifficultySettings(difficulty) {
                    const preset = difficultyPresets[difficulty];
                    if (!preset || difficulty === 'custom') return;
                    
                    isUpdatingFromPreset = true;

                    document.querySelector('[data-gametweak="perfect"]').value = preset.perfect;
                    document.querySelector('[data-gametweak="good"]').value = preset.good;
                    document.querySelector('[data-gametweak="combo"]').value = preset.combo;
                    document.querySelector('[data-gametweak="accuracy"]').value = preset.accuracy;
                    
                    const timingWindowSlider = document.getElementById('timing-window-slider');
                    timingWindowSlider.value = preset.timingWindow;
                    timingWindowSlider.dispatchEvent(new Event('input'));
                    
                    gameTweakSliders.forEach(slider => slider.dispatchEvent(new Event('input')));
                    
                    isUpdatingFromPreset = false;
                }

                difficultySelect.addEventListener('change', () => updateDifficultySettings(difficultySelect.value));
                
                customDifficultySliders.forEach(slider => {
                    slider.addEventListener('input', () => {
                         if (!isUpdatingFromPreset) {
                            difficultySelect.value = 'custom';
                         }
                    });
                });
                
                document.getElementById('countdown-toggle').addEventListener('change', async e => {
                    isCountdownEnabled = e.target.checked;
                    if (midiData && activeGameMode !== 'none') {
                        if (isPlaying) await togglePlayPause();
                        const tempo = midiData.header.tempos[0]?.bpm || countdownDefaultTempo;
                        preRollDuration = isCountdownEnabled ? (60 / tempo) * 4 : 0;
                        seekBar.max = midiData.duration + preRollDuration;
                        updateFilteredPlayback();
                        seekTo(0);
                    }
                });
                document.getElementById('countdown-tempo-slider').addEventListener('input', e => { countdownDefaultTempo = parseInt(e.target.value); });
                isCountdownEnabled = document.getElementById('countdown-toggle').checked;
                countdownDefaultTempo = parseInt(document.getElementById('countdown-tempo-slider').value);

                document.getElementById('metronome-volume-slider').addEventListener('input', e => {
                    if (calMetronome) calMetronome.volume.value = parseFloat(e.target.value);
                });

                document.getElementById('global-offset-slider').addEventListener('input', e => { globalOffset = parseInt(e.target.value) / 1000; });
                document.getElementById('timing-window-slider').addEventListener('input', e => { 
                    timingWindowMultiplier = parseFloat(e.target.value) / 100;
                    updateTimingWindows();
                });
                document.getElementById('perfect-window-slider').addEventListener('input', e => {
                    basePerfectWindow = parseInt(e.target.value) / 1000;
                    updateTimingWindows();
                });
                document.getElementById('good-window-slider').addEventListener('input', e => {
                    baseGoodWindow = parseInt(e.target.value) / 1000;
                    updateTimingWindows();
                });
                document.getElementById('base-score-slider').addEventListener('input', e => { baseScore = parseFloat(e.target.value); });
                document.getElementById('combo-bonus-slider').addEventListener('input', e => { comboBonus = parseFloat(e.target.value); });
                document.getElementById('hold-score-slider').addEventListener('input', e => { holdScorePerSecond = parseInt(e.target.value); });
                document.getElementById('hold-accuracy-slider').addEventListener('input', e => { holdAccuracyIntensity = parseFloat(e.target.value); });
                document.getElementById('overhold-window-slider').addEventListener('input', e => { overholdPenaltyWindow = parseFloat(e.target.value); });
                document.getElementById('velocity-scoring-toggle').addEventListener('change', e => { isVelocityScoringEnabled = e.target.checked; });
                document.getElementById('velocity-sensitivity-slider').addEventListener('input', e => { velocitySensitivity = parseFloat(e.target.value); });
                document.getElementById('autoplay-toggle').addEventListener('change', e => {
                    isAutoPlay = e.target.checked;
                    if (activeGameMode !== 'none' && midiData) {
                        setupAutoPlay();
                    }
                });

                // --- MODIFIED: Added logic for the slider's value display ---
                const kbLanesSlider = document.getElementById('kb-game-lanes-slider');
                const kbLanesValueDisplay = document.getElementById('kb-lanes-value-display'); // Get the new span
                
                kbLanesValueDisplay.textContent = kbLanesSlider.value; // Set initial value

                kbLanesSlider.addEventListener('input', e => {
                    const newLaneCount = parseInt(e.target.value);
                    kbLanesValueDisplay.textContent = newLaneCount; // Update display on change

                    if (newLaneCount !== kbGameNumLanes) {
                        kbGameNumLanes = newLaneCount;
                        const defaultBinds = ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';'];
                        kbGameKeybinds = defaultBinds.slice(0, kbGameNumLanes);
                        kbGame_mapMidiToLanes();
                        updateKeybindsUI();
                    }
                });
                
                const kbAlgorithmSelect = document.getElementById('kb-game-algorithm-select');
                kbAlgorithmSelect.addEventListener('change', e => {
                    kbGameAlgorithm = e.target.value;
                    if (midiData) {
                       kbGame_mapMidiToLanes();
                    }
                });
                kbGameAlgorithm = 'dynamic'; 
                kbAlgorithmSelect.value = 'dynamic';
                
                document.getElementById('kb-game-note-color-toggle').addEventListener('change', e => {
                    kbGameUseNoteColor = e.target.checked;
                });
                kbGameUseNoteColor = document.getElementById('kb-game-note-color-toggle').checked;

                updateDifficultySettings(difficultySelect.value);
            }

            function updateTimingWindows() {
                perfectWindow = basePerfectWindow * timingWindowMultiplier;
                goodWindow = baseGoodWindow * timingWindowMultiplier;
                missWindow = goodWindow + 0.05;
            }

            // --- NEW: Individual algorithm implementations ---

            /**
             * ALGORITHM 1: Greedy Fill
             * Description: A simple and fast algorithm that prioritizes rhythm over pitch. It processes notes
             * chronologically and places each one in the first lane that becomes available.
             * Pros: Maximizes the number of notes included, good for rhythmic accuracy.
             * Cons: No consistent pitch-to-lane mapping.
             */
            function _map_greedyFill(notesToMap) {
                const lanes = Array.from({ length: kbGameNumLanes }, () => []);
                const laneEndTimes = Array(kbGameNumLanes).fill(0);
                let noteIdCounter = 0;

                for (const note of notesToMap) {
                    let bestLane = -1;
                    let earliestEndTime = Infinity;
                    
                    for (let i = 0; i < kbGameNumLanes; i++) {
                        if (laneEndTimes[i] < earliestEndTime) {
                            earliestEndTime = laneEndTimes[i];
                            bestLane = i;
                        }
                    }

                    if (bestLane !== -1 && note.time >= earliestEndTime) {
                        const newNote = { id: `kb-${noteIdCounter++}`, originalId: note.id, time: note.time, duration: note.duration, lane: bestLane, color: getColorForNote(note), state: 'pending', holdState: 'pending', hitTime: -1, score: 0 };
                        lanes[bestLane].push(newNote);
                        laneEndTimes[bestLane] = note.time + note.duration;
                    }
                }
                return lanes;
            }

            /**
             * ALGORITHM 2: Strict Pitch Projection
             * Description: Maps each note to a lane based purely on its musical pitch.
             * Pros: The most musically intuitive layout; low notes are always left, high notes are always right.
             * Cons: Drops a large number of notes in any section with chords or fast, overlapping passages,
             * leading to a sparse and incomplete chart.
             */
            function _map_strictPitch(notesToMap, minMidi, midiRange) {
                const lanes = Array.from({ length: kbGameNumLanes }, () => []);
                const laneEndTimes = Array(kbGameNumLanes).fill(0);
                let noteIdCounter = 0;

                for (const note of notesToMap) {
                    const normalizedPosition = midiRange > 0 ? (note.midi - minMidi) / midiRange : 0.5;
                    let idealLane = Math.floor(normalizedPosition * kbGameNumLanes);
                    if (idealLane >= kbGameNumLanes) idealLane = kbGameNumLanes - 1;

                    if (laneEndTimes[idealLane] <= note.time) {
                        const newNote = { id: `kb-${noteIdCounter++}`, originalId: note.id, time: note.time, duration: note.duration, lane: idealLane, color: getColorForNote(note), state: 'pending', holdState: 'pending', hitTime: -1, score: 0 };
                        lanes[idealLane].push(newNote);
                        laneEndTimes[idealLane] = note.time + note.duration;
                    }
                }
                return lanes;
            }

            /**
             * ALGORITHM 3: Zoned Pitch Mapping (The previous "Bucket" system)
             * Description: A hybrid approach. The song's total pitch range is divided into "zones" for each lane.
             * A note tries to go into its ideal zone, but if that lane is busy, it will search nearby lanes.
             * Pros: Good balance of pitch consistency and rhythmic density. A solid default.
             * Cons: Can feel less adaptive in songs with huge shifts in pitch range (e.g., bassline to solo).
             */
            function _map_zonedPitch(notesToMap, minMidi, midiRange) {
                const finalLanes = Array.from({ length: kbGameNumLanes }, () => []);
                const laneEndTimes = Array(kbGameNumLanes).fill(0);
                let noteIdCounter = 0;
                const bucketSize = midiRange > 0 ? midiRange / kbGameNumLanes : 1;

                for (const note of notesToMap) {
                    const noteOffset = note.midi - minMidi;
                    let idealLane = bucketSize > 0 ? Math.floor(noteOffset / bucketSize) : Math.floor(kbGameNumLanes / 2);
                    if (idealLane >= kbGameNumLanes) idealLane = kbGameNumLanes - 1;
                    if (idealLane < 0) idealLane = 0;

                    let foundLane = -1;
                    for (let distance = 0; distance < kbGameNumLanes && foundLane === -1; distance++) {
                        const rightLane = idealLane + distance;
                        if (rightLane < kbGameNumLanes && laneEndTimes[rightLane] <= note.time) { foundLane = rightLane; break; }
                        const leftLane = idealLane - distance;
                        if (distance > 0 && leftLane >= 0 && laneEndTimes[leftLane] <= note.time) { foundLane = leftLane; break; }
                    }

                    if (foundLane !== -1) {
                        const newNote = { id: `kb-${noteIdCounter++}`, originalId: note.id, time: note.time, duration: note.duration, lane: foundLane, color: getColorForNote(note), state: 'pending', holdState: 'pending', hitTime: -1, score: 0 };
                        finalLanes[foundLane].push(newNote);
                        laneEndTimes[foundLane] = note.time + note.duration;
                    }
                }
                return finalLanes;
            }

            /**
             * ALGORITHM 4: Dynamic Pitch Windowing (The new "Smart" algorithm)
             * Description: The most advanced algorithm. It processes the song in small, chronological chunks ("windows").
             * For each window, it calculates a *local* pitch range and maps the notes within it.
             * Pros: Highly adaptive. A high-pitched solo will use the full lane width, and a subsequent bassline
             * will also use the full lane width. Creates dense, playable, and musically relevant charts.
             * Cons: Slightly more computationally intensive. Pitch-to-lane mapping changes with the music.
             */
            function _map_dynamicWindow(notesToMap) {
                const finalLanes = Array.from({ length: kbGameNumLanes }, () => []);
                const laneEndTimes = Array(kbGameNumLanes).fill(0);
                let noteIdCounter = 0;
                const windowSize = Math.max(kbGameNumLanes * 2, 20); // Process in chunks of 20 notes

                for (let i = 0; i < notesToMap.length; i += windowSize) {
                    const windowNotes = notesToMap.slice(i, i + windowSize);
                    if (windowNotes.length === 0) continue;

                    const windowMidi = windowNotes.map(n => n.midi);
                    const minMidi = Math.min(...windowMidi);
                    const maxMidi = Math.max(...windowMidi);
                    const midiRange = maxMidi - minMidi;
                    const bucketSize = midiRange > 0 ? midiRange / kbGameNumLanes : 1;

                    for (const note of windowNotes) {
                        let idealLane = bucketSize > 0 ? Math.floor((note.midi - minMidi) / bucketSize) : Math.floor(kbGameNumLanes / 2);
                        if (idealLane >= kbGameNumLanes) idealLane = kbGameNumLanes - 1;
                        if (idealLane < 0) idealLane = 0;

                        let foundLane = -1;
                        for (let distance = 0; distance < kbGameNumLanes && foundLane === -1; distance++) {
                            const rightLane = idealLane + distance;
                            if (rightLane < kbGameNumLanes && laneEndTimes[rightLane] <= note.time) { foundLane = rightLane; break; }
                            const leftLane = idealLane - distance;
                            if (distance > 0 && leftLane >= 0 && laneEndTimes[leftLane] <= note.time) { foundLane = leftLane; break; }
                        }

                        if (foundLane === -1) { // If proximity search fails, fall back to a greedy search for this note
                            let earliestEndTime = Infinity;
                            for (let l = 0; l < kbGameNumLanes; l++) {
                                if(laneEndTimes[l] < earliestEndTime) {
                                    earliestEndTime = laneEndTimes[l];
                                    foundLane = l;
                                }
                            }
                        }

                        if (foundLane !== -1 && laneEndTimes[foundLane] <= note.time) {
                            const newNote = { id: `kb-${noteIdCounter++}`, originalId: note.id, time: note.time, duration: note.duration, lane: foundLane, color: getColorForNote(note), state: 'pending', holdState: 'pending', hitTime: -1, score: 0 };
                            finalLanes[foundLane].push(newNote);
                            laneEndTimes[foundLane] = note.time + note.duration;
                        }
                    }
                }
                return finalLanes;
            }
            
            // --- NEW: Individual algorithm implementations ---

            /**
             * ALGORITHM: Alternating Heuristic (Playable)
             * Description: Enforces an alternating left-hand/right-hand pattern to maximize ergonomic flow. It
             * will break the pattern only when necessary to avoid dropping a note.
             * Pros: Very comfortable to play, encourages good habits, reduces strain.
             * Cons: Pitch mapping is secondary, so the layout is not musically intuitive.
             */
            function _map_alternating(notesToMap) {
                const lanes = Array.from({ length: kbGameNumLanes }, () => []);
                const laneEndTimes = Array(kbGameNumLanes).fill(0);
                let noteIdCounter = 0;
                let lastSide = 'right'; // Start by trying to place on the 'left' side.
                const midPoint = Math.floor(kbGameNumLanes / 2);

                for (const note of notesToMap) {
                    const targetSide = lastSide === 'right' ? 'left' : 'right';
                    let foundLane = -1;

                    const searchLanes = (side) => {
                        const laneOrder = side === 'left' ? Array.from({length: midPoint}, (_, i) => i) : Array.from({length: kbGameNumLanes - midPoint}, (_, i) => i + midPoint);
                        let earliestEndTime = Infinity, bestLane = -1;
                        for (const laneIndex of laneOrder) {
                            if (laneEndTimes[laneIndex] < earliestEndTime) {
                                earliestEndTime = laneEndTimes[laneIndex];
                                bestLane = laneIndex;
                            }
                        }
                        if (note.time >= earliestEndTime) return bestLane;
                        return -1;
                    };

                    foundLane = searchLanes(targetSide);
                    if (foundLane === -1) { // If target side is full, try the other side
                        foundLane = searchLanes(targetSide === 'left' ? 'right' : 'left');
                    }
                    
                    if (foundLane !== -1) {
                        const newNote = { id: `kb-${noteIdCounter++}`, originalId: note.id, time: note.time, duration: note.duration, lane: foundLane, color: getColorForNote(note), state: 'pending', holdState: 'pending', hitTime: -1, score: 0 };
                        lanes[foundLane].push(newNote);
                        laneEndTimes[foundLane] = note.time + note.duration;
                        lastSide = foundLane < midPoint ? 'left' : 'right';
                    }
                }
                return lanes;
            }

            /**
             * ALGORITHM: Velocity Projection (Experimental)
             * Description: Maps notes to lanes based on their velocity (how "hard" they were played). Quiet notes
             * go to one side, loud notes to the other.
             * Pros: Creates a unique chart that visually represents the song's dynamics.
             * Cons: Can be un-ergonomic and chaotic, as it has no regard for pitch or rhythm flow.
             */
            function _map_velocity(notesToMap, minVel, velRange) {
                 const finalLanes = Array.from({ length: kbGameNumLanes }, () => []);
                const laneEndTimes = Array(kbGameNumLanes).fill(0);
                let noteIdCounter = 0;

                for (const note of notesToMap) {
                    const normalizedVel = velRange > 0 ? (note.velocity - minVel) / velRange : 0.5;
                    let idealLane = Math.floor(normalizedVel * kbGameNumLanes);
                    if (idealLane >= kbGameNumLanes) idealLane = kbGameNumLanes - 1;

                    let foundLane = -1;
                    for (let distance = 0; distance < kbGameNumLanes && foundLane === -1; distance++) {
                        const rightLane = idealLane + distance;
                        if (rightLane < kbGameNumLanes && laneEndTimes[rightLane] <= note.time) { foundLane = rightLane; break; }
                        const leftLane = idealLane - distance;
                        if (distance > 0 && leftLane >= 0 && laneEndTimes[leftLane] <= note.time) { foundLane = leftLane; break; }
                    }

                    if (foundLane !== -1) {
                        const newNote = { id: `kb-${noteIdCounter++}`, originalId: note.id, time: note.time, duration: note.duration, lane: foundLane, color: getColorForNote(note), state: 'pending', holdState: 'pending', hitTime: -1, score: 0 };
                        finalLanes[foundLane].push(newNote);
                        laneEndTimes[foundLane] = note.time + note.duration;
                    }
                }
                return finalLanes;
            }

            /**
             * ALGORITHM: Least-Loaded Fill (Experimental)
             * Description: A variation of Greedy Fill. For each note, it checks all available lanes and places
             * the note in the one that has the fewest notes in it so far.
             * Pros: Results in a chart with an almost perfectly even distribution of notes across lanes.
             * Cons: Creates very jumpy, unpredictable patterns with no regard for pitch or hand position.
             */
            function _map_density(notesToMap) {
                const lanes = Array.from({ length: kbGameNumLanes }, () => []);
                const laneEndTimes = Array(kbGameNumLanes).fill(0);
                const laneNoteCounts = Array(kbGameNumLanes).fill(0);
                let noteIdCounter = 0;

                for (const note of notesToMap) {
                    const availableLanes = [];
                    for (let i = 0; i < kbGameNumLanes; i++) {
                        if (laneEndTimes[i] <= note.time) {
                            availableLanes.push({ index: i, count: laneNoteCounts[i] });
                        }
                    }

                    if (availableLanes.length > 0) {
                        availableLanes.sort((a, b) => a.count - b.count);
                        const bestLane = availableLanes[0].index;
                        
                        const newNote = { id: `kb-${noteIdCounter++}`, originalId: note.id, time: note.time, duration: note.duration, lane: bestLane, color: getColorForNote(note), state: 'pending', holdState: 'pending', hitTime: -1, score: 0 };
                        lanes[bestLane].push(newNote);
                        laneEndTimes[bestLane] = note.time + note.duration;
                        laneNoteCounts[bestLane]++;
                    }
                }
                return lanes;
            }

            // --- MAIN ROUTER FUNCTION ---
            /**
             * Processes all MIDI notes and maps them to the available keyboard game lanes.
             * This ensures no notes overlap in the same lane.
             */

            function kbGame_mapMidiToLanes() {
                if (!midiData) return;

                const notesToMap = allNotes.filter(note => enabledChannels.has(note.channel))
                                            .sort((a, b) => a.time - b.time || a.midi - b.midi);

                if (notesToMap.length === 0) {
                    kbGameLaneNotes = Array.from({ length: kbGameNumLanes }, () => []);
                    return;
                }
                
                // Pre-calculate stats needed by various algorithms
                const midiNumbers = notesToMap.map(n => n.midi).filter(n => n !== undefined);
                const minMidi = midiNumbers.length > 0 ? Math.min(...midiNumbers) : 60;
                const maxMidi = midiNumbers.length > 0 ? Math.max(...midiNumbers) : 60;
                const midiRange = maxMidi - minMidi;
                
                const velocities = notesToMap.map(n => n.velocity).filter(v => v !== undefined);
                const minVel = velocities.length > 0 ? Math.min(...velocities) : 0;
                const maxVel = velocities.length > 0 ? Math.max(...velocities) : 1;
                const velRange = maxVel - minVel;

                // Route to the selected algorithm
                let mappedLanes;
                switch (kbGameAlgorithm) {
                    case 'alternating':
                        mappedLanes = _map_alternating(notesToMap);
                        break;
                    case 'velocity':
                        mappedLanes = _map_velocity(notesToMap, minVel, velRange);
                        break;
                    case 'density':
                        mappedLanes = _map_density(notesToMap);
                        break;
                    case 'greedy':
                        mappedLanes = _map_greedyFill(notesToMap);
                        break;
                    case 'strict':
                        mappedLanes = _map_strictPitch(notesToMap, minMidi, midiRange);
                        break;
                    case 'zoned':
                        mappedLanes = _map_zonedPitch(notesToMap, minMidi, midiRange);
                        break;
                    case 'dynamic':
                    default:
                        mappedLanes = _map_dynamicWindow(notesToMap);
                        break;
                }
                kbGameLaneNotes = mappedLanes;
            }

            async function enterGameMode(mode) {
                if (activeGameMode === mode) return;
                if (activeGameMode !== 'none') await exitActiveGameMode();

                activeGameMode = mode;
                appContainer.classList.add('game-mode-active');
                
                if (isPlaying) await togglePlayPause();
                gameSessionActive = false;
                resetGame();
                gameHud.style.display = 'block';

                if (mode === 'keyboard') {
                    keyboardGameContainer.style.display = 'flex';
                    pianoContainer.style.display = 'none';
                    visualizerWrapper.style.display = 'none';
                    if (kbGameLaneNotes.length === 0) kbGame_mapMidiToLanes();
                    kbGame_setupLanes();
                    kbGameNotesContainer = document.getElementById('kb-game-notes-container');
                } else { // midi mode
                    pianoContainer.style.display = 'flex';
                    visualizerWrapper.style.display = 'flex';
                    keyboardGameContainer.style.display = 'none';
                    document.querySelectorAll('.note-visual').forEach(el => el.classList.add('pending'));
                }
                
                seekBar.disabled = true;
                if (isAutoPlay) setupAutoPlay();
                
                if (midiData) {
                    const tempo = midiData.header.tempos[0]?.bpm || countdownDefaultTempo;
                    preRollDuration = isCountdownEnabled ? (60 / tempo) * 4 : 0;
                    seekBar.max = midiData.duration + preRollDuration;
                    updateFilteredPlayback();
                    seekTo(0);
                }
            }
            
            async function exitActiveGameMode() {
                if (activeGameMode === 'none') return;

                appContainer.classList.remove('game-mode-active');
                gameHud.style.display = 'none';
                
                if (isPlaying) await togglePlayPause();
                gameSessionActive = false;
                
                if (autoPlayPart) {
                    autoPlayPart.stop(0).dispose();
                    autoPlayPart = null;
                }
                
                if (activeGameMode === 'midi') {
                    if (playerPianoSampler) playerPianoSampler.releaseAll();
                    document.querySelectorAll('.note-visual').forEach(el => {
                        el.className = 'note-visual visible';
                        if(allNotes) {
                            const noteId = parseInt(el.id.replace('note-visual-', ''));
                            const note = allNotes.find(n => n.id === noteId);
                            if(note) applyNoteOutlineStyle(el, note);
                        }
                    });
                } else if (activeGameMode === 'keyboard') {
                    keyboardGameContainer.style.display = 'none';
                    pianoContainer.style.display = 'flex';
                    visualizerWrapper.style.display = 'flex';
                }

                activeGameMode = 'none';
                seekBar.disabled = (midiData === null);

                if (midiData) {
                    const tempo = midiData.header.tempos[0]?.bpm || countdownDefaultTempo;
                    preRollDuration = isPreRollEnabled ? (60 / tempo) * 4 : 0;
                    seekBar.max = midiData.duration + preRollDuration;
                    updateFilteredPlayback();
                    seekTo(0);
                }
            }

// A new function, kbGame_checkPlayerHit_fromMidi, is needed. This function finds the correct note in the game chart corresponding to the incoming MIDI signal and applies the game's scoring and visual feedback logic.

            function kbGame_checkPlayerHit_fromMidi(midi, velocity) {
                const currentTime = Tone.Transport.seconds;
                let bestNote = null;
                let smallestTimeDiff = Infinity;

                // Search through ALL notes in all lanes
                for (const note of kbGameLaneNotes.flat()) {
                    const originalNote = allNotes[note.originalId];
                    // Match the original MIDI note number and ensure the note is pending
                    if (originalNote.midi === midi && note.state === 'pending') {
                        const noteTimeInTransport = note.time + preRollDuration;
                        const timeDiff = Math.abs((noteTimeInTransport + globalOffset) - currentTime);
                        if (timeDiff < smallestTimeDiff && timeDiff < (goodWindow + 0.05)) {
                            smallestTimeDiff = timeDiff;
                            bestNote = note;
                        }
                    }
                }

                if (bestNote) {
                    // A note was found, now score it just like in kbGame_checkPlayerHit
                    const noteTimeInTransport = bestNote.time + preRollDuration;
                    const timeDiff = (noteTimeInTransport + globalOffset) - currentTime;
                    let basePoints = 0;

                    if (Math.abs(timeDiff) <= perfectWindow) {
                        bestNote.hitJudgement = 'perfect'; gameStats.perfect++; basePoints = 100;
                        showJudgement('Perfect', '#4caf50');
                    } else if (Math.abs(timeDiff) <= goodWindow) {
                        bestNote.hitJudgement = 'good'; gameStats.good++; basePoints = 50;
                        showJudgement('Good', '#2196f3');
                    } else {
                        gameStats.extra++; gameStats.combo = 0; showJudgement('Miss', '#f44336'); return null;
                    }
                    
                    const score = (basePoints * baseScore) + (gameStats.combo * comboBonus);
                    bestNote.state = 'hit';
                    bestNote.hitTime = currentTime;
                    bestNote.score = score;
                    gameStats.score += score;
                    gameStats.combo++;

                    const noteEl = document.getElementById(`kb-note-${bestNote.id}`);
                    if (bestNote.duration > 0.15) { // It's a hold note
                         kbGamePlayerHeldKeys.set(bestNote.lane, { gameNote: bestNote, startTime: currentTime });
                         if(noteEl) noteEl.classList.remove('pending');
                    } else { // It's a tap note
                        if (noteEl) noteEl.classList.add('hit');
                    }
                    
                    // Also press the visual key indicator
                    const indicator = document.getElementById(`kb-key-indicator-${bestNote.lane}`);
                    if (indicator) {
                        indicator.classList.add('pressed');
                         if (kbGameUseNoteColor) {
                            indicator.style.backgroundColor = bestNote.color;
                            const contrastColors = getContrastingColors(bestNote.color);
                            indicator.style.color = contrastColors.fill === '#000000' ? '#222' : '#fff';
                            indicator.style.setProperty('--kb-key-glow-color', bestNote.color);
                        }
                    }
                } else {
                    gameStats.extra++;
                    gameStats.combo = 0;
                    showJudgement('Miss', '#f44336');
                }

                if (gameStats.combo > gameStats.maxCombo) gameStats.maxCombo = gameStats.combo;
                updateHUD();
                return bestNote; // Return the hit note so we can map it for release
            }

            function resetGame() {
                gameStats = { ...initialGameStats };
                gameEndingState = 0;
                playerHeldNotes.clear();
                kbGamePlayerHeldKeys.clear();
                midiToLaneMap.clear(); // <-- ADD THIS LINE
                updateHUD();
                if (allNotes) {
                    allNotes.forEach(note => {
                        note.state = 'pending';
                        note.holdState = 'pending';
                        note.hitTime = -1;
                        note.score = 0;
                    });
                }
                 if (kbGameLaneNotes) {
                    kbGameLaneNotes.flat().forEach(note => {
                        note.state = 'pending';
                        note.holdState = 'pending';
                        note.hitTime = -1;
                        note.score = 0;
                    });
                }

                // Visual reset
                if (activeGameMode === 'midi') {
                    document.querySelectorAll('.note-visual').forEach(el => {
                        el.className = 'note-visual visible pending';
                        if(allNotes) {
                            const noteId = parseInt(el.id.replace('note-visual-', ''));
                            const note = allNotes.find(n => n.id === noteId);
                            if(note) applyNoteOutlineStyle(el, note);
                        }
                        el.style.display = enabledChannels.has(parseInt(el.dataset.channel)) ? 'block' : 'none';
                    });
                } else if (activeGameMode === 'keyboard') {
                    if (kbGameNotesContainer) kbGameNotesContainer.innerHTML = '';
                    kbGameRenderedNoteIds.clear();
                }

                seekTo(0);
            }
            
            function setupAutoPlay() {
                if (autoPlayPart) autoPlayPart.dispose();
                autoPlayPart = null;

                if (!isAutoPlay || activeGameMode === 'none') return;
                
                if (activeGameMode === 'midi') {
                    const notesToPlay = allNotes.filter(note => enabledChannels.has(note.channel));
                    autoPlayPart = new Tone.Part((time, note) => {
                        playerPianoSampler.triggerAttackRelease(note.name, note.duration, time, note.velocity);
                        
                        Tone.Draw.schedule(() => {
                            hitExactNote(note, note.velocity);
                            if (note.duration > 0.15) {
                                playerHeldNotes.set(note.midi, {
                                    gameNote: note,
                                    startTime: time,
                                    initialScore: note.score
                                });
                            }
                        }, time);

                        if (note.duration > 0.15) {
                            Tone.Transport.scheduleOnce(() => {
                                handleNoteRelease(note.midi);
                            }, time + note.duration);
                        }
                    }, notesToPlay).start(preRollDuration);

                } else if (activeGameMode === 'keyboard') {
                    const notesToPlay = kbGameLaneNotes.flat();
                    autoPlayPart = new Tone.Part((time, note) => {
                        const originalNote = allNotes[note.originalId];
                         playerPianoSampler.triggerAttackRelease(originalNote.name, originalNote.duration, time, originalNote.velocity);
                         
                        Tone.Draw.schedule(() => {
                            kbGame_hitExactNote(note);
                            const indicator = document.getElementById(`kb-key-indicator-${note.lane}`);
                            if (indicator) {
                                indicator.classList.add('pressed');
                                if (kbGameUseNoteColor) {
                                    indicator.style.backgroundColor = note.color;
                                    const contrastColors = getContrastingColors(note.color);
                                    indicator.style.color = contrastColors.fill === '#000000' ? '#222' : '#fff';
                                    indicator.style.setProperty('--kb-key-glow-color', note.color);
                                }
                            }
                        }, time);
                        
                        const releaseTime = time + note.duration;
                        // MODIFIED: Schedule the visual key release 50ms early to create a clean separation.
                        const visualReleaseTime = Math.max(time + 0.05, releaseTime - 0.05);

                        if (note.duration > 0.15) { 
                            Tone.Transport.scheduleOnce(() => {
                                kbGame_handleKeyRelease(note.lane, true);
                            }, releaseTime);
                            
                            Tone.Draw.schedule(() => {
                                const indicator = document.getElementById(`kb-key-indicator-${note.lane}`);
                                if (indicator) {
                                    indicator.classList.remove('pressed');
                                    if (kbGameUseNoteColor) {
                                        indicator.style.backgroundColor = '';
                                        indicator.style.color = '';
                                        indicator.style.removeProperty('--kb-key-glow-color');
                                    }
                                }
                            }, visualReleaseTime); // Use the new, earlier release time

                        } else { 
                            Tone.Draw.schedule(() => {
                                const indicator = document.getElementById(`kb-key-indicator-${note.lane}`);
                                if (indicator) {
                                    indicator.classList.remove('pressed');
                                    if (kbGameUseNoteColor) {
                                        indicator.style.backgroundColor = '';
                                        indicator.style.color = '';
                                        indicator.style.removeProperty('--kb-key-glow-color');
                                    }
                                }
                            }, time + 0.1); 
                        }
                    }, notesToPlay).start(preRollDuration);
                }
            }

            function markNoteAsMiss(note) {
                if (note.state === 'miss') return;
                note.state = 'miss';
                gameStats.miss++;
                gameStats.combo = 0;
                
                if (note.score > 0) {
                    gameStats.score -= note.score;
                    if(gameStats.score < 0) gameStats.score = 0;
                    if (note.hitJudgement === 'perfect') gameStats.perfect--;
                    else if (note.hitJudgement === 'good') gameStats.good--;
                }

                updateHUD();
                const noteEl = document.getElementById(`note-visual-${note.id}`);
                if (noteEl) {
                    noteEl.classList.remove('pending', 'hit');
                    noteEl.classList.add('missed');
                }
            }
            
            function hitExactNote(note, velocity) {
                if (note.state !== 'pending') return;

                const score = ((100 * baseScore) + (gameStats.combo * comboBonus));
                
                note.state = 'hit';
                note.hitJudgement = 'perfect';
                note.hitTime = Tone.Transport.seconds;
                note.score = score;
                gameStats.score += score;
                gameStats.combo++;
                gameStats.perfect++;
                
                if (gameStats.combo > gameStats.maxCombo) {
                    gameStats.maxCombo = gameStats.combo;
                }

                const noteEl = document.getElementById(`note-visual-${note.id}`);
                if (noteEl) {
                    noteEl.classList.remove('pending');
                    noteEl.classList.add('hit');
                }
                
                showJudgement('Perfect', '#4caf50');
                updateHUD();
            }

            function checkPlayerHit(midi, velocity) {
                const currentTime = Tone.Transport.seconds;
                let bestNote = null;
                let smallestTimeDiff = Infinity;

                for (const note of allNotes) {
                    if (note.midi === midi && note.state === 'pending' && enabledChannels.has(note.channel)) {
                        const noteTimeInTransport = note.time + preRollDuration;
                        const timeDiff = Math.abs((noteTimeInTransport + globalOffset) - currentTime);
                        if (timeDiff < smallestTimeDiff && timeDiff < (goodWindow + 0.05)) {
                            smallestTimeDiff = timeDiff;
                            bestNote = note;
                        }
                    }
                }
                
                if (bestNote) {
                    const noteTimeInTransport = bestNote.time + preRollDuration;
                    const timeDiff = (noteTimeInTransport + globalOffset) - currentTime;
                    let basePoints = 0;

                    if (Math.abs(timeDiff) <= perfectWindow) {
                        bestNote.hitJudgement = 'perfect';
                        gameStats.perfect++;
                        basePoints = 100;
                        showJudgement('Perfect', '#4caf50');
                    } else if (Math.abs(timeDiff) <= goodWindow) {
                        bestNote.hitJudgement = 'good';
                        gameStats.good++;
                        basePoints = 50;
                        showJudgement('Good', '#2196f3');
                    } else {
                        gameStats.extra++;
                        gameStats.combo = 0;
                        showJudgement('Miss', '#f44336');
                        return;
                    }
                    
                    let velocityMultiplier = 1.0;
                    if (isVelocityScoringEnabled) {
                        const velDiff = Math.abs(bestNote.velocity - velocity);
                        velocityMultiplier = Math.max(0, 1 - (velDiff * velocitySensitivity));
                    }

                    const score = ((basePoints * baseScore) + (gameStats.combo * comboBonus)) * velocityMultiplier;
                    
                    bestNote.state = 'hit';
                    bestNote.hitTime = currentTime;
                    bestNote.score = score;
                    gameStats.score += score;
                    gameStats.combo++;

                    playerHeldNotes.set(midi, {
                        gameNote: bestNote,
                        startTime: currentTime,
                        initialScore: score
                    });
                    
                    const noteEl = document.getElementById(`note-visual-${bestNote.id}`);
                    if (noteEl) {
                        noteEl.classList.remove('pending');
                        noteEl.classList.add('hit');
                    }
                } else {
                    gameStats.extra++;
                    gameStats.combo = 0;
                    showJudgement('Miss', '#f44336');
                }

                if (gameStats.combo > gameStats.maxCombo) {
                    gameStats.maxCombo = gameStats.combo;
                }
                updateHUD();
            }
            
            function handleNoteRelease(midi, isOverheld = false) {
                if (!playerHeldNotes.has(midi)) return;
                
                const heldInfo = playerHeldNotes.get(midi); // Get the whole info object
                const { gameNote } = heldInfo;
                playerHeldNotes.delete(midi); // Delete from map immediately

                if (gameNote.state !== 'hit' || isAutoPlay) return;

                // If the note was already marked as over-held by the animation loop, we don't need to do anything else.
                // The miss has already been registered and penalty applied.
                if (heldInfo.isOverheld) {
                    lastHeldNoteStatus = `Over-held and released (Note ${gameNote.midi})`;
                    updateHUD();
                    return;
                }

                // This logic now only applies to notes released *before* the over-hold penalty window.
                const releaseTime = Tone.Transport.seconds;
                const playerHoldDuration = releaseTime - gameNote.hitTime;
                const requiredHoldDuration = gameNote.duration * holdAccuracyIntensity;
                
                if (isOverheld) { 
                    markNoteAsMiss(gameNote);
                    showJudgement('Miss', '#f44336');
                    lastHeldNoteStatus = `Over-held (Note ${gameNote.midi})`;
                } else if (playerHoldDuration < requiredHoldDuration) {
                    markNoteAsMiss(gameNote);
                    showJudgement('Miss', '#f44336');
                    lastHeldNoteStatus = `Held too short (Note ${gameNote.midi})`;
                } else {
                    lastHeldNoteStatus = `Held OK (Note ${gameNote.midi})`;
                    gameNote.holdState = 'released_ok';
                }
                 updateHUD();
            }

            function showJudgement(text, color) {
                judgementText.textContent = text;
                judgementText.style.color = color;
                judgementText.style.animation = 'none';
                judgementText.offsetHeight;
                judgementText.style.animation = 'judgement-anim 0.7s ease-out forwards';
            }

            function updateHUD() {
                scoreDisplay.textContent = `Score: ${Math.round(gameStats.score).toLocaleString()}`;
                if (gameStats.combo > 1) {
                    comboDisplay.textContent = `${gameStats.combo} Combo`;
                    comboDisplay.classList.add('visible');
                } else {
                    comboDisplay.classList.remove('visible');
                }
            }

            function showResults() {
                gameSessionActive = false;
                const totalNotes = (activeGameMode === 'keyboard' ? kbGameLaneNotes.flat() : allNotes.filter(n => enabledChannels.has(n.channel))).length;
                const successfulHits = gameStats.perfect + gameStats.good;
                const accuracy = totalNotes > 0 ? ((successfulHits / totalNotes) * 100) : 0;
                const finalAccuracy = Math.max(0, accuracy).toFixed(2);

                document.getElementById('result-score').textContent = Math.round(gameStats.score).toLocaleString();
                document.getElementById('result-accuracy').textContent = `${finalAccuracy}%`;
                document.getElementById('result-max-combo').textContent = gameStats.maxCombo;
                document.getElementById('result-perfect').textContent = gameStats.perfect;
                document.getElementById('result-good').textContent = gameStats.good;
                document.getElementById('result-miss').textContent = gameStats.miss;
                document.getElementById('result-extra').textContent = gameStats.extra;
                document.getElementById('result-total-notes').textContent = totalNotes;

                resultsOverlay.classList.add('visible');
            }

            // --- Sync Calibration Functions ---
            function resetSyncUI() {
                syncTaps = [];
                syncAvgOffset.textContent = '-- ms';
                syncStability.textContent = '-- ms';
                applySyncBtn.disabled = true;
                applySyncBtn.style.display = 'none';
                syncStartBtn.style.display = 'inline-block';
                syncInstructions.innerHTML = "Press 'Begin Test' then tap any key on your MIDI device in time with the sound and visual pulse.";
                updateSyncPlot();
            }

            async function openSyncModal() {
                if (Tone.context.state !== 'running') await Tone.start();

                wasPlayingBeforeSync = isPlaying;
                if (isPlaying) await togglePlayPause();
                if (Tone.Transport.state === 'started') Tone.Transport.stop();
                Tone.Transport.cancel();

                resetSyncUI();
                syncModal.classList.add('visible');
            }

            function startSync() {
                syncStartBtn.style.display = 'none';
                isSyncing = true;
                nextBeatTime = Tone.now() + SYNC_INTERVAL; 

                syncLoop = new Tone.Loop(time => {
                    nextBeatTime = time;
                    calMetronome.triggerAttack("C4", time);
                    
                    Tone.Draw.schedule(() => {
                        if (!isSyncing) return;
                        syncBar.style.animation = 'none';
                        syncBar.offsetHeight;
                        syncBar.style.animation = `sync-bar-fill ${SYNC_INTERVAL}s linear forwards`;
                    }, time);
                }, SYNC_INTERVAL).start(SYNC_INTERVAL);

                Tone.Transport.start();
            }

            function handleSyncTap() {
                if (!isSyncing || syncTaps.length >= SYNC_TOTAL_TAPS) return;

                const tapTime = Tone.now();
                const offset = (tapTime - nextBeatTime) * 1000;
                syncTaps.push(offset);
                
                updateSyncResults();
                
                if (syncTaps.length >= SYNC_TOTAL_TAPS) {
                    finishSync();
                }
            }
            
            function updateSyncResults() {
                if (syncTaps.length === 0) return;

                const avg = syncTaps.reduce((sum, val) => sum + val, 0) / syncTaps.length;
                syncAvgOffset.textContent = `${Math.round(avg)} ms`;

                if (syncTaps.length > 1) {
                    const mean = avg;
                    const stdDev = Math.sqrt(syncTaps.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / syncTaps.length);
                    syncStability.textContent = `${stdDev.toFixed(1)} ms`;
                } else {
                    syncStability.textContent = '-- ms';
                }
                
                updateSyncPlot();
            }

            function updateSyncPlot() {
                const svgNS = "http://www.w3.org/2000/svg";
                syncPlot.innerHTML = '';
                
                const createLine = (x1, y1, x2, y2, className) => {
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                    if(className) line.classList.add(className);
                    return line;
                };

                syncPlot.appendChild(createLine('0', '0', '0', '50'));
                syncPlot.appendChild(createLine('0', '25', '100', '25'));
                syncPlot.appendChild(createLine('50', '0', '50', '50', 'center-line'));

                const maxOffset = 150; 
                syncTaps.forEach(offset => {
                    const circle = document.createElementNS(svgNS, 'circle');
                    const x = 50 + (offset / maxOffset) * 50;
                    circle.setAttribute('cx', Math.max(2, Math.min(98, x)));
                    circle.setAttribute('cy', Math.random() * 40 + 5);
                    circle.setAttribute('r', '3');
                    syncPlot.appendChild(circle);
                });
            }

            function finishSync() {
                isSyncing = false;
                if(syncLoop) syncLoop.stop(0);
                if (Tone.Transport.state === 'started') Tone.Transport.stop();
                Tone.Transport.cancel();
                
                syncInstructions.innerHTML = "Calibration complete! Review your results below.";
                if (syncTaps.length >= 2) {
                    applySyncBtn.disabled = false;
                    applySyncBtn.style.display = 'inline-block';
                }
            }

            function endSync(shouldApply) {
                isSyncing = false;
                if(syncLoop) syncLoop.stop(0);
                if(Tone.Transport.state === 'started') Tone.Transport.stop();
                Tone.Transport.cancel();
                syncLoop = null;

                syncModal.classList.remove('visible');
                
                if (shouldApply && syncTaps.length > 0) {
                    const avg = parseFloat(syncAvgOffset.textContent);
                    if (!isNaN(avg)) {
                        const newOffset = Math.max(-200, Math.min(200, Math.round(avg)));
                        document.getElementById('global-offset-slider').value = newOffset;
                        globalOffset = newOffset / 1000;
                    }
                }
                
                if (midiData) updateFilteredPlayback();
                if (wasPlayingBeforeSync) {
                    seekTo(currentScrollTime); 
                    togglePlayPause();
                } else if (midiData) {
                    seekTo(currentScrollTime);
                }
            }
            
            // --- MIDI Packs Functions ---
            function parsePackInfo(text) {
                const info = { midiTitles: {} };
                let isMidiSection = false;
                text.split('\n').forEach(line => {
                    line = line.trim();
                    if (line.toLowerCase() === 'midis:') {
                        isMidiSection = true;
                        return;
                    }

                    if (isMidiSection) {
                        const midiMatch = line.match(/^(\d+):\s*(.*)/);
                        if (midiMatch) {
                            info.midiTitles[midiMatch[1]] = midiMatch[2].trim();
                        }
                    } else {
                        const [key, ...value] = line.split(':');
                        if (key && value.length > 0) {
                            info[key.trim().toLowerCase()] = value.join(':').trim();
                        }
                    }
                });
                return info;
            }

            function getDifficultyColor(rating) {
                const num = parseFloat(rating) || 0;
                if (num >= 4.0) return '#e74c3c'; // Red
                if (num >= 2.5) return '#f39c12'; // Orange
                return '#2ecc71'; // Green
            }

            function renderDifficultyStars(rating) {
                const num = parseFloat(rating) || 0;
                let starsHtml = '';
                for (let i = 1; i <= 5; i++) {
                    if (num >= i) {
                        starsHtml += '★'; // Full star, will inherit gold color from parent
                    } else if (num >= i - 0.5) {
                        starsHtml += '<span class="half-star">★</span>'; // Half star wrapper
                    } else {
                        starsHtml += '<span class="empty-star">★</span>'; // Empty star wrapper
                    }
                }
                return starsHtml;
            }

            // NEW: Helper to convert hex to rgba for gradient
            function hexToRgba(hex, alpha) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 4) {
                    r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3];
                } else if (hex.length == 7) {
                    r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6];
                }
                return `rgba(${+r},${+g},${+b},${alpha})`;
            }

            async function processMidiPacks(files) {
                if (files.length === 0) return;
                loadingOverlay.classList.add('visible');
                
                const packs = {};
                for (const file of files) {
                    const pathParts = file.webkitRelativePath.split('/');
                    if (pathParts.length < 2) continue;
                    const packName = pathParts[pathParts.length - 2];
                    if (!packs[packName]) {
                        packs[packName] = { files: [], info: null, midis: [], midiData: [] };
                    }
                    packs[packName].files.push(file);
                }

                for (const packName in packs) {
                    const pack = packs[packName];
                    const infoFile = pack.files.find(f => f.name.toLowerCase() === 'pack.txt');
                    if (infoFile) {
                        const text = await infoFile.text();
                        pack.info = parsePackInfo(text);
                    } else {
                        pack.info = {
                            title: `Custom MIDI Pack #${customPackCounter++}`,
                            description: 'A collection of custom MIDI files.',
                            difficulty: '0',
                            midiTitles: null
                        };
                    }
                    pack.midis = pack.files.filter(f => f.name.endsWith('.mid') || f.name.endsWith('.midi'));
                    
                    const midiPromises = pack.midis.map(file => {
                        return new Promise(async (resolve) => {
                            try {
                                const buffer = await file.arrayBuffer();
                                const midi = new Midi(buffer);
                                const noteCount = midi.tracks.reduce((acc, track) => acc + track.notes.length, 0);
                                const fileNumberMatch = file.name.match(/(\d+)\.mid(i)?$/);
                                const fileNumber = fileNumberMatch ? fileNumberMatch[1] : null;
                                resolve({ file, noteCount, fileNumber });
                            } catch (e) {
                                console.error(`Could not parse ${file.name}`, e);
                                resolve(null); // Resolve with null if parsing fails
                            }
                        });
                    });
                    
                    pack.midiData = (await Promise.all(midiPromises)).filter(Boolean); // Filter out any nulls
                }
                midiPacksData = packs;
                renderMidiPacks();
                loadingOverlay.classList.remove('visible');
            }

            function renderMidiPacks() {
                midiPacksList.innerHTML = '';
                const fragment = document.createDocumentFragment();

                for (const packName in midiPacksData) {
                    const pack = midiPacksData[packName];
                    if (pack.midiData.length === 0) continue;

                    const li = document.createElement('li');
                    li.className = 'midipack-item';
                    const difficultyColor = getDifficultyColor(pack.info?.difficulty);
                    li.style.borderLeft = `4px solid ${difficultyColor}`;

                    li.innerHTML = `
                        <div class="midipack-header">
                            <p class="midipack-title">${pack.info?.title || packName}</p>
                            ${pack.info?.description ? `<p class="midipack-description">${pack.info.description}</p>` : ''}
                            <div class="midipack-meta">
                                <span class="difficulty-stars">${renderDifficultyStars(pack.info?.difficulty)}</span>
                                <span>${pack.midiData.length} songs</span>
                            </div>
                        </div>
                        <div class="midipack-songlist-container">
                           <div class="midipack-songlist-inner">
                                <ul class="midipack-songlist"></ul>
                           </div>
                        </div>
                    `;
                    
                    const header = li.querySelector('.midipack-header');
                    header.style.backgroundImage = `linear-gradient(90deg, ${hexToRgba(difficultyColor, 0.15)} 0%, transparent 70%)`;


                    const songListEl = li.querySelector('.midipack-songlist');
                    pack.midiData.sort((a,b) => (a.fileNumber || a.file.name).localeCompare(b.fileNumber || b.file.name, undefined, {numeric: true})).forEach(midi => {
                        const songItem = document.createElement('li');
                        songItem.className = 'midipack-song-item';
                        
                        const title = (pack.info.midiTitles && midi.fileNumber) ? pack.info.midiTitles[midi.fileNumber] : midi.file.name.replace(/\.mid(i)?$/i, '');

                        songItem.innerHTML = `<span class="song-title" title="${title}">${title}</span><span class="song-note-count">${midi.noteCount} notes</span>`;

                        songItem.addEventListener('click', () => handleFile(midi.file));
                        songListEl.appendChild(songItem);
                    });

                    li.querySelector('.midipack-header').addEventListener('click', () => {
                        li.classList.toggle('expanded');
                    });

                    fragment.appendChild(li);
                }
                midiPacksList.appendChild(fragment);
            }
            
            // --- MODIFIED/IMPLEMENTED: Keyboard Rhythm Game Functions ---
            

            function kbGame_setupLanes() {
                kbGameLanesContainer.innerHTML = '<div id="kb-game-notes-container"></div>'; 
                kbGameNotesContainer = document.getElementById('kb-game-notes-container');
                kbGameHitZone.innerHTML = '';
                
                const fragmentLanes = document.createDocumentFragment();
                const fragmentHitZone = document.createDocumentFragment();

                for (let i = 0; i < kbGameNumLanes; i++) {
                    const lane = document.createElement('div');
                    lane.className = 'kb-game-lane';
                    fragmentLanes.appendChild(lane);
                    
                    const indicator = document.createElement('div');
                    indicator.className = 'kb-key-indicator';
                    indicator.id = `kb-key-indicator-${i}`;
                    indicator.textContent = kbGameKeybinds[i]?.toUpperCase() || '?';
                    indicator.dataset.lane = i; // Store lane index

                    // --- NEW: Add event listeners for mouse/touch interaction ---
                    indicator.addEventListener('pointerdown', (e) => {
                        e.preventDefault();
                        const laneIndex = parseInt(e.target.dataset.lane);
                        // Only press if the lane isn't already being held down
                        if (!kbGamePlayerHeldKeys.has(laneIndex)) {
                            kbGame_handleKeyPress(laneIndex);
                        }
                    });

                    indicator.addEventListener('pointerup', (e) => {
                        e.preventDefault();
                        const laneIndex = parseInt(e.target.dataset.lane);
                        kbGame_handleKeyRelease(laneIndex);
                    });

                    indicator.addEventListener('pointerleave', (e) => {
                        e.preventDefault();
                        const laneIndex = parseInt(e.target.dataset.lane);
                        // Release the key if the mouse leaves while being held down
                        if (e.buttons === 1 && kbGamePlayerHeldKeys.has(laneIndex)) {
                           kbGame_handleKeyRelease(laneIndex);
                        }
                    });

                    fragmentHitZone.appendChild(indicator);
                }
                kbGameLanesContainer.insertBefore(fragmentLanes, kbGameNotesContainer);
                kbGameHitZone.appendChild(fragmentHitZone);
            }
            
            function kbGame_updateVisuals(songTime) {
                if (!kbGameNotesContainer) return;
                
                kbGameNotesContainer.style.transform = `translateY(${songTime * noteFallSpeed}px)`;
                
                const viewHeight = kbGameLanesContainer.offsetHeight;
                const visibleDuration = viewHeight / noteFallSpeed;
                const viewStartTime = songTime - (visibleDuration * 0.1);
                const viewEndTime = songTime + visibleDuration * 1.1;
                
                const shouldBeVisibleIds = new Set();
                const fragment = document.createDocumentFragment();

                kbGameLaneNotes.flat().forEach(note => {
                    const noteEndTime = note.time + note.duration;
                    if (noteEndTime >= viewStartTime && note.time <= viewEndTime) {
                        shouldBeVisibleIds.add(note.id);
                        if (!kbGameRenderedNoteIds.has(note.id)) {
                             const noteEl = document.createElement('div');
                             noteEl.id = `kb-note-${note.id}`;
                             noteEl.className = 'kb-game-note';
                             if(note.duration > 0.15) noteEl.classList.add('hold');
                             
                             const laneWidthPercent = 100 / kbGameNumLanes;
                             noteEl.style.left = `${laneWidthPercent * note.lane + (laneWidthPercent * 0.05)}%`;
                             noteEl.style.width = `${laneWidthPercent * 0.9}%`;

                             noteEl.style.bottom = `${note.time * noteFallSpeed}px`;
                             noteEl.style.height = `${Math.max(5, note.duration * noteFallSpeed)}px`;
                             noteEl.style.backgroundColor = note.color;
                             
                             // --- MODIFICATION START ---
                             // This logic now correctly handles visual states for both tap and hold notes.
                             if (note.state === 'pending') {
                                 noteEl.classList.add('pending');
                             } else if (note.state === 'miss') {
                                 noteEl.classList.add('missed');
                             } else if (note.state === 'hit') {
                                 // If a note is 'hit', only apply the .hit class (which makes it disappear)
                                 // if it's a tap note. Hold notes will be handled by the .active-hold class later.
                                 if (note.duration <= 0.15) {
                                     noteEl.classList.add('hit');
                                 }
                             }
                             // --- MODIFICATION END ---
                             
                             fragment.appendChild(noteEl);
                             kbGameRenderedNoteIds.add(note.id);
                        }
                    }
                });
                
                if (fragment.childElementCount > 0) {
                    kbGameNotesContainer.appendChild(fragment);
                }

                kbGameRenderedNoteIds.forEach(id => {
                    if (!shouldBeVisibleIds.has(id)) {
                        document.getElementById(`kb-note-${id}`)?.remove();
                        kbGameRenderedNoteIds.delete(id);
                    }
                });

                // This part of the function adds the glow to held notes. It now works correctly
                // because the hold notes are no longer being hidden by the '.hit' class.
                document.querySelectorAll('.kb-game-note.active-hold').forEach(el => el.classList.remove('active-hold'));
                kbGamePlayerHeldKeys.forEach(heldInfo => {
                    const noteEl = document.getElementById(`kb-note-${heldInfo.gameNote.id}`);
                    if (noteEl) {
                        noteEl.classList.add('active-hold');
                        noteEl.style.setProperty('--glow-color', heldInfo.gameNote.color);
                    }
                });
            }

            function kbGame_handleKeyPress(laneIndex) {
                 const indicator = document.getElementById(`kb-key-indicator-${laneIndex}`);
                 if (indicator) indicator.classList.add('pressed');
                 if (isAutoPlay || !gameSessionActive) return;

                 const gameNote = kbGame_checkPlayerHit(laneIndex);
                 if (gameNote) {
                    const originalNote = allNotes[gameNote.originalId];
                    playerPianoSampler.triggerAttack(originalNote.name, Tone.now(), originalNote.velocity);
                    
                    if (kbGameUseNoteColor && indicator) {
                        indicator.style.backgroundColor = gameNote.color;
                        const contrastColors = getContrastingColors(gameNote.color);
                        indicator.style.color = contrastColors.fill === '#000000' ? '#222' : '#fff';
                        // Set the custom glow color variable
                        indicator.style.setProperty('--kb-key-glow-color', gameNote.color);
                    }
                 }
            }

            function kbGame_handleKeyRelease(laneIndex, force = false) {
                 const indicator = document.getElementById(`kb-key-indicator-${laneIndex}`);
                 if (indicator) {
                     indicator.classList.remove('pressed');
                     indicator.style.backgroundColor = '';
                     indicator.style.color = '';
                     indicator.style.removeProperty('--kb-key-glow-color');
                 }
                 if (isAutoPlay && !force) return;
                 
                 if (kbGamePlayerHeldKeys.has(laneIndex)) {
                     const heldInfo = kbGamePlayerHeldKeys.get(laneIndex); // Get the whole object
                     const { gameNote } = heldInfo;
                     const originalNote = allNotes[gameNote.originalId];
                     playerPianoSampler.triggerRelease(originalNote.name, Tone.now());

                    if (isAutoPlay && force) {
                        gameNote.holdState = 'released_ok';
                        kbGamePlayerHeldKeys.delete(laneIndex); 
                        return; 
                    }

                     kbGamePlayerHeldKeys.delete(laneIndex); // Delete from map

                     if(gameNote.state !== 'hit') return;

                    // If it was over-held, the penalty is already done. Just exit.
                    if (heldInfo.isOverheld) {
                        lastHeldNoteStatus = `Over-held and released (Lane ${laneIndex+1})`;
                        updateHUD();
                        return;
                    }

                     const releaseTime = Tone.Transport.seconds;
                     const playerHoldDuration = releaseTime - gameNote.hitTime;
                     const requiredHoldDuration = gameNote.duration * holdAccuracyIntensity;
                     const noteEl = document.getElementById(`kb-note-${gameNote.id}`);

                     if (force || playerHoldDuration < requiredHoldDuration) {
                         kbGame_markNoteAsMiss(gameNote);
                         showJudgement('Miss', '#f44336');
                         lastHeldNoteStatus = `Held too short (Lane ${laneIndex+1})`;
                     } else {
                         lastHeldNoteStatus = `Held OK (Lane ${laneIndex+1})`;
                         gameNote.holdState = 'released_ok';
                         if (noteEl) noteEl.classList.add('hit');

                     }
                     updateHUD();
                 }
            }
            
            function kbGame_checkPlayerHit(laneIndex) {
                const currentTime = Tone.Transport.seconds;
                let bestNote = null;
                let smallestTimeDiff = Infinity;

                for (const note of kbGameLaneNotes[laneIndex]) {
                    if (note.state === 'pending') {
                        const noteTimeInTransport = note.time + preRollDuration;
                        const timeDiff = Math.abs((noteTimeInTransport + globalOffset) - currentTime);
                        if (timeDiff < smallestTimeDiff && timeDiff < (goodWindow + 0.05)) {
                            smallestTimeDiff = timeDiff;
                            bestNote = note;
                        }
                    }
                }
                
                if (bestNote) {
                    const noteTimeInTransport = bestNote.time + preRollDuration;
                    const timeDiff = (noteTimeInTransport + globalOffset) - currentTime;
                    let basePoints = 0;

                    if (Math.abs(timeDiff) <= perfectWindow) {
                        bestNote.hitJudgement = 'perfect'; gameStats.perfect++; basePoints = 100;
                        showJudgement('Perfect', '#4caf50');
                    } else if (Math.abs(timeDiff) <= goodWindow) {
                        bestNote.hitJudgement = 'good'; gameStats.good++; basePoints = 50;
                        showJudgement('Good', '#2196f3');
                    } else {
                        gameStats.extra++; gameStats.combo = 0; showJudgement('Miss', '#f44336'); return null;
                    }
                    
                    const score = (basePoints * baseScore) + (gameStats.combo * comboBonus);
                    bestNote.state = 'hit';
                    bestNote.hitTime = currentTime;
                    bestNote.score = score;
                    gameStats.score += score;
                    gameStats.combo++;

                    const noteEl = document.getElementById(`kb-note-${bestNote.id}`);
                    if (bestNote.duration > 0.15) { // It's a hold note
                         kbGamePlayerHeldKeys.set(laneIndex, { gameNote: bestNote, startTime: currentTime });
                         if(noteEl) noteEl.classList.remove('pending');
                    } else { // It's a tap note
                        if (noteEl) noteEl.classList.add('hit');
                    }
                } else {
                    gameStats.extra++;
                    gameStats.combo = 0;
                    showJudgement('Miss', '#f44336');
                }

                if (gameStats.combo > gameStats.maxCombo) gameStats.maxCombo = gameStats.maxCombo;
                updateHUD();
                // MODIFIED: Return the keyboard game note object
                return bestNote;
            }

             function kbGame_markNoteAsMiss(note) {
                if (note.state === 'miss') return;
                note.state = 'miss';
                gameStats.miss++;
                gameStats.combo = 0;
                
                if (note.score > 0) {
                    gameStats.score -= note.score;
                    if(gameStats.score < 0) gameStats.score = 0;
                    if (note.hitJudgement === 'perfect') gameStats.perfect--;
                    else if (note.hitJudgement === 'good') gameStats.good--;
                }

                updateHUD();
                const noteEl = document.getElementById(`kb-note-${note.id}`);
                if (noteEl) {
                    noteEl.classList.remove('pending', 'active-hold');
                    noteEl.classList.add('missed');
                }
            }

            // MODIFIED
            function kbGame_hitExactNote(note) {
                if (note.state !== 'pending') return;
                const score = (100 * baseScore) + (gameStats.combo * comboBonus);
                note.state = 'hit';
                note.hitJudgement = 'perfect';
                note.hitTime = Tone.Transport.seconds;
                note.score = score;
                gameStats.score += score;
                gameStats.combo++;
                gameStats.perfect++;
                if (gameStats.combo > gameStats.maxCombo) gameStats.maxCombo = gameStats.maxCombo;
                
                const noteEl = document.getElementById(`kb-note-${note.id}`);
                if(note.duration <= 0.15) { // It's a tap note
                    if (noteEl) noteEl.classList.add('hit');
                } else { // It's a hold note
                    if(noteEl) {
                        noteEl.classList.remove('pending');
                        // MODIFIED: Directly add the 'active-hold' class to make the note glow.
                        noteEl.classList.add('active-hold');
                    }
                    kbGamePlayerHeldKeys.set(note.lane, { gameNote: note, startTime: Tone.Transport.seconds });
                }

                showJudgement('Perfect', '#4caf50');
                updateHUD();
            }

            // --- Event Listeners ---
            visualizerWrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (!midiData || activeGameMode !== 'none') return;
                const scrollSensitivity = 0.01;
                let timeChange = e.deltaY * scrollSensitivity;
                if (invertScroll) timeChange *= -1;
                scrollTargetTime += timeChange;
                scrollTargetTime = Math.max(0, Math.min(scrollTargetTime, midiData.duration + preRollDuration));
                startSmoothScroll();
            });
            fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
            midiPacksInput.addEventListener('change', (e) => processMidiPacks(e.target.files));
            playPauseBtn.addEventListener('click', togglePlayPause);
            seekBar.addEventListener('input', () => seekTo(parseFloat(seekBar.value)));
            
            volumeSlider.addEventListener('input', (e) => { 
                if (playerGain) playerGain.gain.value = parseFloat(e.target.value);
            });
            
            accompanimentVolumeSlider.addEventListener('input', (e) => {
                if (accompanimentGain) accompanimentGain.gain.value = parseFloat(e.target.value);
            });
            const dropZoneContent = dropZone.querySelector('.panel-content-inner');
            dropZoneContent.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
            dropZoneContent.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
            dropZoneContent.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFile(e.dataTransfer.files[0]); });
            
            continueBtn.addEventListener('click', () => {
                resultsOverlay.classList.remove('visible');
                exitActiveGameMode();
            });
            restartGameBtn.addEventListener('click', () => {
                resultsOverlay.classList.remove('visible');
                gameSessionActive = false;
                if (!isPlaying) {
                   togglePlayPause();
                } else {
                    resetGame();
                }
            });
            
            openSyncBtn.addEventListener('click', openSyncModal);
            syncStartBtn.addEventListener('click', startSync);
            resetSyncBtn.addEventListener('click', resetSyncUI);
            cancelSyncBtn.addEventListener('click', () => endSync(false));
            applySyncBtn.addEventListener('click', () => endSync(true));
            
            // --- Initializations ---
            createPiano();
            createGridLines();
            initializePopSynth();
            initializeInstruments();
            initializeTabs();
            initializeSettings();
            initializeMinimizablePanels();
            initializeMidiInput();
            initializeModal('channel-settings-modal-overlay', [], ['#modal-close-btn']);
            initializeModal('game-mode-choice-modal', ['#game-mode-btn'], ['.modal-close', '#start-midi-game-btn', '#start-kb-game-btn']);
            document.getElementById('start-midi-game-btn').addEventListener('click', () => enterGameMode('midi'));
            document.getElementById('start-kb-game-btn').addEventListener('click', () => enterGameMode('keyboard'));
            initializeKeybinds();

            // --- NEW: Tutorial Event Listeners ---
            tutorialIcon.addEventListener('click', startTutorial);
            tutorialCloseBtn.addEventListener('click', endTutorial);
            tutorialOverlay.addEventListener('click', (e) => {
                // Close if the dark overlay area is clicked, but not the caption box.
                if (e.target === tutorialOverlay) {
                    endTutorial();
                }
            });
            tutorialNextBtn.addEventListener('click', () => {
                showTutorialStep(currentTutorialStep + 1);
            });
            tutorialPrevBtn.addEventListener('click', () => {
                showTutorialStep(currentTutorialStep - 1);
            });
        });
    </script>
</body>
</html>
